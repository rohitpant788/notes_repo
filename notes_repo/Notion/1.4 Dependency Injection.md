## **🔹 Introduction to Dependency Injection**

- **What is Dependency Injection (DI)?**
    - A **design pattern** used to achieve **loose coupling** in software applications.
    - Instead of creating dependencies manually, dependencies are **injected** from an external source.
    - **Spring Framework** uses DI to manage object dependencies automatically.
- **Why is Dependency Injection Important?**
    - **Removes manual dependency management** (No need to create, maintain, or destroy objects).
    - **Encourages modular and reusable code**.
    - **Reduces tight coupling**, making the application flexible and scalable.
- **Is Dependency Injection Only for Spring Boot?**
    - No! DI is a **core concept** of the **Spring Framework**, not limited to Spring Boot.
    - It is implemented using the **IoC (Inversion of Control) Container** to inject dependencies dynamically.

---

## **🔹 Understanding Dependency Injection with an Analogy**

- Imagine **Alice**, a baker, wants to bake a **chocolate cake**.
- She **depends** on multiple **ingredients** (e.g., frosting, syrup).
- Instead of fetching ingredients herself, she **hires Bob** to do this.
- **Bob fetches the required ingredients** as needed.

### **🛠️ Mapping This Analogy to Dependency Injection**

|   |   |
|---|---|
|**Analogy Component**|**Spring Boot Component**|
|Alice (Baker)|Developer (Writes the code)|
|Cake|Application|
|Ingredients (Frosting, Syrup)|Dependencies (Beans)|
|Bob (Helper)|Spring DI Framework|
|Bakery|Codebase|

✅ **Now, Alice (Developer) can focus only on baking (writing business logic) while Bob (Spring DI) handles dependencies.**

✅ This reduces **tight coupling** and makes it easier to switch dependencies dynamically.

---

## **🔹 Why Do We Need Dependency Injection?**

- **Without DI**: Developers must manually manage objects, increasing complexity.
- **With DI**: The framework **automatically injects** dependencies when required.

### **✅ Benefits of Dependency Injection**

1. **Loosely Coupled Code**
    - Components don’t directly depend on each other.
    - Allows swapping different implementations easily.
2. **Better Maintainability**
    - Changes in dependencies do not require modifying dependent classes.
    - Reduces risk of bugs when modifying code.
3. **Improved Testability**
    - Dependencies can be **mocked** during unit testing.
    - No need to set up real services or databases.
4. **Flexible Configurations**
    - External configurations (e.g., application.properties) manage dependencies.
    - Supports different environments (dev, test, prod).

---

## **🔹 Official Definition of Dependency Injection**

> "Dependency Injection (DI) is a technique in which the Spring Framework manages object dependencies and injects them into components instead of creating them manually."

- Instead of components **creating dependencies**, the **Spring IoC (Inversion of Control) container** provides them.

---

## **🔹 Implementing Dependency Injection in Spring Boot**

### **📌 Step 1: Creating a Service (DB Service)**

```Java
java
CopyEdit
@Service
public class DBService {
    public String getData() {
        return "Fetching Data...";
    }
}

```

- `**@Service**` annotation marks the class as a Spring-managed component.

### **📌 Step 2: Injecting the Service**

```Java
java
CopyEdit
@RestController
public class MyController {

    @Autowired
    private DBService dbService; // Dependency Injection

    @GetMapping("/data")
    public String fetchData() {
        return dbService.getData();
    }
}

```

- `**@Autowired**` automatically injects `DBService` into `MyController`.
- The **Spring IoC container** initializes `DBService` and injects it wherever required.

---

## **🔹 Types of Dependency Injection in Spring Boot**

Spring Boot supports three types of dependency injection:

1. **Field Injection**
2. **Constructor Injection** (Recommended)
3. **Setter Injection**

---

### **📌 1️⃣ Field Injection (Using** `**@Autowired**`**)**

```Java
java
CopyEdit
@Service
public class MyService {

    @Autowired  // Field Injection
    private DBService dbService;

    public String processData() {
        return dbService.getData();
    }
}

```

**🚨 Drawback:**

- Cannot use `final` keyword, making it harder to enforce immutability.
- **Not recommended** for mandatory dependencies.

---

### **📌 2️⃣ Constructor Injection (Best Practice)**

```Java
java
CopyEdit
@Service
public class MyService {
    private final DBService dbService;

    @Autowired
    public MyService(DBService dbService) {  // Constructor Injection
        this.dbService = dbService;
    }

    public String processData() {
        return dbService.getData();
    }
}

```

✅ **Advantages of Constructor Injection**:

- **Enforces immutability** (Can declare `final` fields).
- **Ensures mandatory dependencies are initialized**.
- **Easier unit testing** (Allows passing mock dependencies).

✅ **Spring Boot 4+ supports constructor injection automatically (no need for** `**@Autowired**`**).**

---

## **🔹 Using Environment Variables for Dependency Injection in Spring Boot**

Spring Boot allows us to configure dependencies dynamically using **environment variables**, which are useful for **deployment in different environments (dev, test, prod, etc.)**.

### **📌 How Environment Variables Override Properties?**

|   |   |
|---|---|
|`**application.properties**` **Key**|**Corresponding Environment Variable**|
|`deploy.environment=development`|`DEPLOY_ENVIRONMENT=production`|

---

### **📌 Step 1: Define Property in** `**application.properties**`

```Plain
properties
CopyEdit
deploy.environment=development

```

By default, the application will load **development configurations**.

---

### **📌 Step 2: Override Using Environment Variable**

On **Linux/macOS**, use:

```Shell
bash
CopyEdit
export DEPLOY_ENVIRONMENT=production

```

On **Windows (CMD)**, use:

```Plain
cmd
CopyEdit
set DEPLOY_ENVIRONMENT=production

```

On **Windows (PowerShell)**, use:

```PowerShell
powershell
CopyEdit
$env:DEPLOY_ENVIRONMENT="production"

```

✅ Now, the application will **load production-specific dependencies** instead of development.

---

### **📌 Step 3: Use** `**@ConditionalOnProperty**` **to Load Beans Dynamically**

```Java
java
CopyEdit
@Component
@ConditionalOnProperty(name = "deploy.environment", havingValue = "development")
public class DevDatabase implements Database {
    @Override
    public String getData() {
        return "Development Database Data";
    }
}

@Component
@ConditionalOnProperty(name = "deploy.environment", havingValue = "production")
public class ProdDatabase implements Database {
    @Override
    public String getData() {
        return "Production Database Data";
    }
}

```

✅ **Spring Boot will now pick the correct database bean based on the** `**DEPLOY_ENVIRONMENT**` **environment variable!**

---

## **🔹 Summary**

|   |   |
|---|---|
|**Feature**|**Description**|
|**What is DI?**|A technique where the Spring IoC container manages dependencies.|
|**Why DI?**|Achieves **loose coupling**, **better maintainability**, and **testability**.|
|**Types of DI?**|Field Injection, Constructor Injection (Best Practice), Setter Injection.|
|**Best Practice?**|Use **Constructor Injection** (supports `final` fields).|
|**Loose Coupling?**|Achieved via interfaces and configuration files.|
|**Switching Beans?**|Use `@ConditionalOnProperty` or environment variables.|

---

### **🔥 Key Takeaway**

🔹 **Never hardcode environment-specific configurations in the code!**

🔹 Always use **environment variables** to dynamically inject configurations and ensure smooth **deployment in different environments**.

🔹 **Spring Boot simplifies DI** with built-in support for **Bean Management** and **Auto Configuration**.