- What does @ Data annotation do ?
    
    When you use `@Data` on a class, Lombok automatically generates:
    
    1. **Getters and Setters** for all fields.
    2. `**toString()**` **Method** for easy debugging.
    3. `**equals()**` **and** `**hashCode()**` **Methods** for object comparison.
    4. **A No-Argument Constructor** if no other constructors are defined.
    
    ### **Example Usage**
    
    ```Java
    import lombok.Data;
    
    @Data
    public class Person {
        private String name;
        private int age;
    }
    
    ```
    
    ### **Equivalent Java Code Without Lombok**
    
    Without Lombok, you'd have to manually write:
    
    ```Java
    java
    CopyEdit
    public class Person {
        private String name;
        private int age;
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Person{name='" + name + "', age=" + age + "}";
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Person person = (Person) o;
            return age == person.age && Objects.equals(name, person.name);
        }
    
        @Override
        public int hashCode() {
            return Objects.hash(name, age);
        }
    }
    
    ```
    
    Using `@Data` saves a lot of code!
    
    ---
    
    ### **Key Features of** `**@Data**`
    
    1. **Generates Getters & Setters** ‚Äì Provides standard getter and setter methods.
    2. **Implements** `**toString()**` ‚Äì Prints object details conveniently.
    3. **Implements** `**equals()**` **and** `**hashCode()**` ‚Äì Ensures proper object comparison.
    4. **Default Constructor** ‚Äì Creates a no-args constructor automatically.
    
    ---
    
    ### **When to Use** `**@Data**`**?**
    
    - When you need a **POJO (Plain Old Java Object)** with standard methods.
    - When you want to reduce boilerplate code.
    - When you're working with **DTOs (Data Transfer Objects)** or **Entity Classes**.
    
    ### **When NOT to Use** `**@Data**`**?**
    
    - If your class has **custom business logic** that overrides `equals()` or `hashCode()`, using `@Data` might not be the best choice.
    - If your class has **immutable fields**, use `@Value` instead.
    
    ### **Common Alternatives to** `**@Data**`
    
    |   |   |
    |---|---|
    |Annotation|Purpose|
    |`@Getter`|Generates only getters|
    |`@Setter`|Generates only setters|
    |`@ToString`|Generates `toString()`|
    |`@EqualsAndHashCode`|Generates `equals()` and `hashCode()`|
    |`@Value`|Makes class immutable (final fields, no setters)|
    
      
    

  

- So If I am using @ Data annotation , does it means i can skip @ NoArgsConstructor ?
    
    Yes, if you are using `@Data` from **Lombok**, then you **do not need to explicitly declare** `@NoArgsConstructor`, unless your use case specifically requires it.
    
    ### **Why?**
    
    - By default, `@Data` **provides a no-argument constructor only if** there are **no final fields** in the class.
    - If your class has **final fields**, Lombok **does not generate a no-args constructor** (because final fields must be initialized).
    - If you explicitly need a **no-args constructor**, you should use `@NoArgsConstructor`.
    
    ---
    
    ### **Example 1: When** `**@Data**` **Alone is Enough**
    
    ```Java
    java
    CopyEdit
    import lombok.Data;
    
    @Data
    public class Employee {
        private String name;
        private int age;
    }
    
    ```
    
    ‚úÖ In this case, Lombok **automatically generates**:
    
    - A **no-argument constructor** (`public Employee() {}`).
    - Getters, setters, `toString()`, `equals()`, and `hashCode()`.
    
    ---
    
    ### **Example 2: When You Need** `**@NoArgsConstructor**`
    
    ```Java
    java
    CopyEdit
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @NoArgsConstructor
    public class Employee {
        private String name;
        private int age;
    }
    
    ```
    
    ‚úÖ Here, explicitly adding `@NoArgsConstructor` **is redundant** because `@Data` already provides it.
    
    ---
    
    ### **Example 3: When** `**@NoArgsConstructor**` **is Required**
    
    ```Java
    java
    CopyEdit
    import lombok.Data;
    import lombok.NoArgsConstructor;
    
    @Data
    @NoArgsConstructor  // Required because of final fields
    public class Employee {
        private final String name;
        private final int age;
    }
    
    ```
    
    üö® **Without** `**@NoArgsConstructor**`**, Lombok will not generate a no-args constructor** because `name` and `age` are `final`.
    
    ---
    
    ### **Conclusion**
    
    |   |   |   |
    |---|---|---|
    |Case|`@Data` Alone|`@NoArgsConstructor` Needed?|
    |No final fields|‚úÖ No-arg constructor is generated|‚ùå Not needed|
    |Contains final fields|‚ùå No-arg constructor **not** generated|‚úÖ Required|
    
    üîπ **If your class has final fields, use** `**@NoArgsConstructor**` **explicitly.**
    
    üîπ **If your class has non-final fields,** `**@Data**` **is enough.**
    

  

- In JPA Entity class, there are two more annotations. One is @ Entity, other is @ Table. So, why do we require these two? Can't simply @ Table annotation works? Or do we require both?
    
    n a **JPA (Java Persistence API) entity class**, both `@Entity` and `@Table` annotations serve different purposes, and you **cannot replace** `**@Entity**` **with** `**@Table**`. You require both, but `@Table` is optional.
    
    ---
    
    ### **1Ô∏è‚É£** `**@Entity**` **Annotation (Required)**
    
    - **Purpose**: Marks a Java class as a **JPA Entity**, meaning it is mapped to a database table.
    - **Mandatory**: Without `@Entity`, Hibernate (or any JPA provider) **won‚Äôt recognize the class** as a database entity.
    - **Default Table Name**: If `@Table` is **not specified**, the table name defaults to the **class name**.
    
    ‚úÖ **Example (Without** `**@Table**`**)**
    
    ```Java
    java
    CopyEdit
    import jakarta.persistence.Entity;
    
    @Entity
    public class Employee {
        private Long id;
        private String name;
    }
    
    ```
    
    üîπ **Here,** `**Employee**` **is an entity, and the corresponding table will be** `**Employee**` **(default behavior).**
    
    üîπ **You cannot omit** `**@Entity**`**, as it is required for JPA to recognize the class.**
    
    ---
    
    ### **2Ô∏è‚É£** `**@Table**` **Annotation (Optional)**
    
    - **Purpose**: Specifies the **table name** in the database.
    - **Optional**: Used only when you want to override the **default table name**.
    - **Custom Schema Support**: Allows specifying a schema.
    
    ‚úÖ **Example (With** `**@Table**`**)**
    
    ```Java
    java
    CopyEdit
    import jakarta.persistence.Entity;
    import jakarta.persistence.Table;
    
    @Entity
    @Table(name = "EMPLOYEES", schema = "HR")
    public class Employee {
        private Long id;
        private String name;
    }
    
    ```
    
    üîπ **Now, the table name is** `**EMPLOYEES**` **instead of the default** `**Employee**`.
    
    üîπ **The table is part of the** `**HR**` **schema.**
    
    ---
    
    ### **Can We Use** `**@Table**` **Without** `**@Entity**`**?**
    
    üö® **No!**
    
    The `@Table` annotation only defines table metadata but does **not** mark a class as an entity.
    
    If you omit `@Entity`, Hibernate will **ignore** the class, and no table mapping will occur.
    
    ‚úÖ **Correct Usage (Both** `**@Entity**` **and** `**@Table**` **Together)**
    
    ```Java
    java
    CopyEdit
    @Entity
    @Table(name = "EMPLOYEES")
    public class Employee {
        private Long id;
        private String name;
    }
    
    ```
    
    üö® **Incorrect Usage (Only** `**@Table**` **‚Äì Will Not Work)**
    
    ```Java
    java
    CopyEdit
    @Table(name = "EMPLOYEES")
    public class Employee {
        private Long id;
        private String name;
    }
    
    ```
    
    üîπ **This class is NOT an entity! Hibernate will ignore it.**
    
    ---
    
    ### **Final Answer: Why Do We Need Both?**
    
    |   |   |   |
    |---|---|---|
    |Annotation|Required?|Purpose|
    |`@Entity`|‚úÖ **Yes**|Marks the class as an entity, allowing JPA to manage it.|
    |`@Table`|‚ùå No (Optional)|Used to **override** the default table name and schema.|
    
    - You **must** use `@Entity` for JPA to recognize the class.
    - `@Table` is **only needed** if you want a **custom table name** or **schema**.

  

- Why do we have the `@Repository` annotation in repository interfaces that extend `JpaRepository`? Can I replace it with `@Component` or `@Service`? What was the need for creating the `@Repository` annotation if `@Component` or `@Service` also serves the purpose?
    
    ### **Why Do We Use** `**@Repository**` **in Spring Data JPA?**
    
    In Spring, the `@Repository` annotation is used **to mark a class as a Data Access Object (DAO)** that interacts with the database. It is part of **Spring‚Äôs Stereotype Annotations**, just like `@Component`, `@Service`, and `@Controller`.
    
    ### **1Ô∏è‚É£ Why Do We Need** `**@Repository**`**?**
    
    - **Exception Translation**: `@Repository` **automatically converts database exceptions** (like `SQLException`) into **Spring's DataAccessException**, making error handling more consistent.
    - **Component Scanning**: Spring automatically **detects** and registers repositories as beans.
    - **Clear Semantics**: It indicates that the class is a **data access layer** component.
    
    ### **2Ô∏è‚É£ Example Usage of** `**@Repository**`
    
    ```Java
    java
    CopyEdit
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;
    
    @Repository
    public interface EmployeeRepository extends JpaRepository<Employee, Long> {
        Employee findByName(String name);
    }
    
    ```
    
    üîπ This marks `EmployeeRepository` as a **Spring-managed bean** and enables JPA functionalities.
    
    ---
    
    ### **3Ô∏è‚É£ Can We Replace** `**@Repository**` **with** `**@Component**` **or** `**@Service**`**?**
    
    ### **‚úÖ Yes, technically you can, but you shouldn‚Äôt!**
    
    - `@Component` will allow Spring to detect the repository, but **you lose exception translation**.
    - `@Service` is meant for **business logic, not data access**.
    - `@Repository` is **specifically designed** for repositories.
    
    ---
    
    ### **4Ô∏è‚É£ Why Was** `**@Repository**` **Created If** `**@Component**` **Works?**
    
    1. **Specialized for DAOs** ‚Äì It clearly marks classes meant for **database interactions**.
    2. **Exception Handling** ‚Äì It enables **Spring‚Äôs automatic exception translation**, which `@Component` does not provide.
    3. **Code Readability** ‚Äì Makes it clear that the interface is a **repository**, improving maintainability.
    
    ---
    
    ### **5Ô∏è‚É£ Comparison:** `**@Repository**` **vs.** `**@Component**` **vs.** `**@Service**`
    
    |   |   |   |   |
    |---|---|---|---|
    |Annotation|Purpose|Exception Translation?|When to Use?|
    |`@Repository`|Data access layer (DAO)|‚úÖ Yes (JPA/Hibernate exceptions converted)|Use for database repositories|
    |`@Service`|Business logic layer|‚ùå No|Use for service classes (business logic)|
    |`@Component`|Generic Spring bean|‚ùå No|Use for generic Spring-managed components|
    
    ---
    
    ### **6Ô∏è‚É£ What Happens If We Don‚Äôt Use** `**@Repository**`**?**
    
    - Spring **will not apply exception translation**, and database-related exceptions will be unchecked (`SQLException` instead of `DataAccessException`).
    - The repository will still work if you replace `@Repository` with `@Component`, but **best practices suggest using** `**@Repository**` **for better clarity and maintainability**.
    
    ---
    
    ### **Final Answer**
    
    ‚úÖ **Use** `**@Repository**` **for JPA Repositories.**
    
    ‚úÖ `**@Component**` **works but does not provide exception translation.**
    
    ‚ùå **Do not use** `**@Service**` **for repositories, as it's meant for business logic.**
    

  

- Let's suppose I have two entities: one is **Department**, and the other is **Employee**. The relationship is that **each department will have one manager who is an employee, but not every employee is necessarily a manager of a department**. How would you establish this relationship between the two entities in JPA?
    
    ---
    
      
    
      
    
    Since each department has **one** manager, but **not every employee is a manager**, this is a **one-to-one relationship** from the department's perspective. However, an employee may or may not be associated as a manager with a department.
    
    We can represent this in JPA using a **unidirectional or bidirectional** `@OneToOne` mapping.
    
    ---
    
    ### **1Ô∏è‚É£ Establishing the Relationship (Recommended Approach)**
    
    In the **Department entity**, we should establish a `@OneToOne` relationship where the `manager_id` refers to an `Employee`. The `@JoinColumn` ensures that the foreign key (`manager_id`) is stored in the `Department` table.
    
    ### **Department Entity**
    
    ```Java
    java
    CopyEdit
    import jakarta.persistence.*;
    
    @Entity
    public class Department {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne
        @JoinColumn(name = "manager_id", unique = true)  // Foreign key
        private Employee manager; // Refers to an Employee who is a manager
    
        // Getters and Setters
    }
    
    ```
    
    ‚úÖ **Explanation:**
    
    - `@OneToOne` ‚Üí Ensures that **one department has exactly one manager**.
    - `@JoinColumn(name = "manager_id")` ‚Üí Specifies that `manager_id` in the `Department` table is a **foreign key** referencing `Employee.id`.
    - `unique = true` ‚Üí Ensures that **one employee can manage only one department at a time**.
    
    ---
    
    ### **Employee Entity**
    
    ```Java
    import jakarta.persistence.*;
    
    @Entity
    public class Employee {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
        private String position; // Can be "Manager" or any other role
    
        // Getters and Setters
    }
    ```
    
    ‚úÖ **Explanation:**
    
    - The **Employee entity does not contain a reference to Department** because not all employees are managers.
    - The `position` field can indicate whether an employee is a **manager** or not.
    
    ---
    
    ### **2Ô∏è‚É£ Database Schema Representation**
    
    This relationship results in the following table structure:
    
    ### **Employee Table**
    
    |   |   |   |
    |---|---|---|
    |id|name|position|
    |1|Alice|Manager|
    |2|Bob|Engineer|
    |3|Charlie|Analyst|
    
    ### **Department Table**
    
    |   |   |   |
    |---|---|---|
    |id|name|manager_id|
    |1|IT|1 (Alice)|
    |2|HR|NULL|
    
    üîπ **Only employees who are managers will have their IDs referenced in the** `**Department**` **table.**
    
    üîπ **Bob and Charlie are employees, but they are not managers, so they won‚Äôt be referenced in the** `**Department**` **table.**
    
    ---
    
    ### **3Ô∏è‚É£ Optional: Making It Bidirectional (If Needed)**
    
    If you want to allow an `Employee` entity to see which `Department` they manage, you can add a **mappedBy** property in `Employee`.
    
    ### **Updated Employee Entity (Bidirectional)**
    
    ```Java
    import jakarta.persistence.*;
    
    @Entity
    public class Employee {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
        private String position;
    
        @OneToOne(mappedBy = "manager") // Bidirectional mapping
        private Department department;
    
        // Getters and Setters
    }
    
    ```
    
    ‚úÖ **Now, we can access an employee‚Äôs department (if they are a manager).**
    
    _==**Please note mappedBy tells this relationship is already mapped by manager field in Department entity. and there is no need to create a separate column in Employee table for manager.**==_
    
    ---
    
    ### **4Ô∏è‚É£ Summary:**
    
    |   |   |   |
    |---|---|---|
    |Relationship|Annotation Used|Explanation|
    |**One Department ‚Üí One Manager**|`@OneToOne` (in `Department`)|Each department has **one** manager who is an employee.|
    |**An Employee May or May Not Be a Manager**|No explicit mapping in `Employee`|Since not all employees are managers, `Employee` doesn't require a reference to `Department`.|
    |**Foreign Key Handling**|`@JoinColumn(name = "manager_id")`|Ensures `manager_id` in `Department` refers to an `Employee`.|
    |**Uni vs. Bidirectional**|`mappedBy = "manager"` (Optional)|If bidirectional, `Employee` can see the `Department` they manage.|
    
    ---
    
    ### **Final Answer:**
    
    To model the relationship where **each department has one manager who is an employee, but not every employee is a manager**, use **a** `**@OneToOne**` **mapping in the** `**Department**` **entity with** `**@JoinColumn(name = "manager_id")**`. This keeps the relationship efficient while maintaining integrity.
    

  

- Why is `Optional<T>` used in `findById()`?
    
    **‚ùå Problem Without Using** `**Optional**`
    
    Imagine you retrieve a department by its ID, but it **might not exist**. Without `Optional`, you might handle it like this:
    
    ```Java
    Department department = departmentRepository.findById(id);
    if (department == null) {
        throw new EntityNotFoundException("Department not found");
    }
    ```
    
    üö® **Difficulties:**
    
    - If you forget to check for `null`, it leads to a `**NullPointerException (NPE)**` at runtime.
    - Requires **manual null-checking** everywhere.
    
    ### **‚úÖ Solution Using** `**Optional<T>**`
    
    ```Java
    Optional<Department> department = departmentRepository.findById(id);
    ```
    
    - Now, `department` is either **present or empty**, preventing accidental `null` access.
    - Makes it **explicit** that the entity may not exist.
    
    üìå **With** `**Optional**`**, null-checking is built into the API, reducing NPE risks!**
    

- What is the difference between `flatMap()` and `map()` in `Optional<T>`?
    
    ### **‚ùå Problem: Using** `**map()**` **Incorrectly**
    
    If we use `map()` to retrieve the employee inside the department lookup:
    
    ```Java
    Optional<Optional<Employee>> manager = departmentRepository.findById(id).map(Department::getManager);
    ```
    
    üö® **Difficulties:**
    
    - This results in `Optional<Optional<Employee>>`, making it hard to use.
    - We have **nested Optionals**, which require extra handling to extract the value.
    
    ### **‚úÖ Solution Using** `**flatMap()**`
    
    ```Java
    Optional<Employee> manager = departmentRepository.findById(id).flatMap(Department::getManager);
    ```
    
    üìå **With** `**flatMap()**`**, the inner** `**Optional<Employee>**` **is automatically "flattened", making it easier to work with.**
    

  

- How do you safely update an entity retrieved as `Optional<T>`?
    
    ### **‚ùå Problem Without Using** `**Optional**`
    
    ```Java
    
    Department department = departmentRepository.findById(departmentId);
    Employee employee = employeeRepository.findById(employeeId);
    
    if (department == null || employee == null) {
        throw new RuntimeException("Department or Employee not found");
    }
    
    department.setManager(employee);
    departmentRepository.save(department);
    ```
    
    üö® **Difficulties:**
    
    - Requires multiple `if` checks.
    - Higher chance of **forgetting a null check**, leading to `NullPointerException`.
    
    ### **‚úÖ Solution Using** `**Optional**`
    
    ```Java
    public Department assignManager(Long departmentId, Long employeeId) {
        return departmentRepository.findById(departmentId)
            .flatMap(department -> employeeRepository.findById(employeeId)
                .map(employee -> {
                    department.setManager(employee);
                    return departmentRepository.save(department);
                })
            ).orElseThrow(() -> new EntityNotFoundException("Department or Employee not found"));
    }
    ```
    
    üìå **With** `**Optional**`**, we elegantly handle null cases without extra** `**if**` **statements.**
    

  

- When should you use `map()` instead of `flatMap()`?
    
    ### **‚ùå Problem: Using** `**flatMap()**` **When** `**map()**` **Is Enough**
    
    If we only need to extract an employee‚Äôs name:
    
    ```Java
    
    Optional<String> employeeName = employeeRepository.findById(employeeId).flatMap(Employee::getName);
    
    ```
    
    üö® **Difficulties:**
    
    - This fails because `getName()` returns `String`, not `Optional<String>`.
    - `flatMap()` requires a function returning `Optional<T>`.
    
    ### **‚úÖ Correct Approach Using** `**map()**`
    
    ```Java
    Optional<String> employeeName = employeeRepository.findById(employeeId).map(Employee::getName);
    ```
    
    üìå **Use** `**map()**` **when transforming values inside** `**Optional**`**, and** `**flatMap()**` **when dealing with nested Optionals!**
    

  

- How can you handle missing entities when updating data?
    
    ### **‚ùå Problem Without Proper Handling**
    
    ```Java
    public Department assignManager(Long departmentId, Long employeeId) {
        Department department = departmentRepository.findById(departmentId).get();
        Employee employee = employeeRepository.findById(employeeId).get();
    
        department.setManager(employee);
        return departmentRepository.save(department);
    }
    ```
    
    üö® **Difficulties:**
    
    - `.get()` **throws** `**NoSuchElementException**` if the entity is missing.
    - Can cause **runtime failures in production**.
    
    ### **‚úÖ Solution Using** `**orElseThrow()**`
    
    ```Java
    java
    CopyEdit
    public Department assignManager(Long departmentId, Long employeeId) {
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new EntityNotFoundException("Department not found"));
    
        Employee employee = employeeRepository.findById(employeeId)
            .orElseThrow(() -> new EntityNotFoundException("Employee not found"));
    
        department.setManager(employee);
        return departmentRepository.save(department);
    }
    ```
    
    üìå **With** `**orElseThrow()**`**, we explicitly handle missing entities without crashing the application.**
    

  

- Let's suppose I have two relationships in my entity class:  
    One-to-One (  
    `@OneToOne`) One-to-Many (`@OneToMany`)  
    Which relationship will be **eagerly loaded** by default, and which one will be **lazily loaded**?  
      
      
    
    By default, **JPA follows these loading strategies for relationships**:
    
    |   |   |
    |---|---|
    |Relationship Type|Default Fetch Type|
    |`@OneToOne`|**EAGER** (by default)|
    |`@OneToMany`|**LAZY** (by default)|
    
    ---
    
    ### **1Ô∏è‚É£ One-to-One (**`**@OneToOne**`**) ‚Üí Eager Loading by Default**
    
    ### **Example:**
    
    ```Java
    
    @Entity
    public class Department {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne
        @JoinColumn(name = "manager_id")
        private Employee manager; // One manager per department
    
    }
    ```
    
    üîπ **Default Behavior:** When a `Department` is fetched, its `manager` **is loaded immediately (EAGER fetching)**.
    
    üîπ **Problem with Eager Loading:** If we only need the `Department`, but it always loads the `Employee`, it could lead to unnecessary database queries and performance overhead.
    
    ‚úÖ **Solution:** Explicitly mark it as `LAZY` if needed.
    
    ```Java
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id")
    private Employee manager;
    ```
    
    ---
    
    ### **One-to-Many (**`**@OneToMany**`**) ‚Üí Lazy Loading by Default**
    
    ### **Example:**
    
    ```Java
    @Entity
    public class Department {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToMany(mappedBy = "department")
        private List<Employee> employees; // One department has many employees
    
    }
    ```
    
    **Default Behavior:** When a `Department` is fetched, the `employees` list **is NOT loaded immediately**. It is fetched **only when accessed** (Lazy Loading).
    
    üîπ **Why Lazy by Default?** Since a department can have many employees, eager loading could cause **huge performance issues** by fetching unnecessary records.
    
    ‚úÖ **Solution:** If eager loading is required, explicitly set it as:
    
    ```Java
    @OneToMany(mappedBy = "department", fetch = FetchType.EAGER)
    private List<Employee> employees;
    ```
    
    **Warning:** Setting `@OneToMany(fetch = FetchType.EAGER)` can cause the **N+1 query problem**, leading to performance degradation.
    
    ---
    
    ### **3Ô∏è‚É£ Summary Table: Fetch Type Behavior**
    
    |   |   |   |
    |---|---|---|
    |Relationship Type|Default Fetch Type|Reason|
    |`@OneToOne`|**EAGER**|Assumes only **one** associated object, so loads it immediately.|
    |`@OneToMany`|**LAZY**|Assumes a **large collection**, so avoids loading unless needed.|
    
    ---
    
    ### **4Ô∏è‚É£ Best Practices**
    
    - **Prefer** `**LAZY**` **loading whenever possible** to avoid performance issues.
    - **For** `**@OneToOne**`**, change to** `**LAZY**` if you don‚Äôt always need the related entity.
    - **For** `**@OneToMany**`**, keep it** `**LAZY**` and use `JOIN FETCH` in queries when necessary.
    
      
    
      
    
      
      
      
      
      
    
- If I don‚Äôt explicitly mention the fetch type in a **bidirectional** `@OneToOne` relationship where `Department` has a **manager (Employee)** reference and `Employee` has a **department** reference, will it create a **recursive loop**?  
    If **yes**, in what scenario does it happen?  
    How does it occur in a **Spring Boot REST API** when returning JSON?  
    How can we **avoid this issue** effectively?  
      
    
    ### **1Ô∏è‚É£ Will It Create a Recursive Loop?**
    
    ‚úÖ **Yes, a recursive loop occurs** when serializing entities in a REST API **without using DTOs or proper annotations**.
    
    üìå **The issue happens when:**
    
    - A `Department` is fetched and returned as JSON.
    - The `Department` entity has a reference to `Employee` (manager).
    - The `Employee` entity also has a reference back to `Department`.
    - The serialization process **keeps looping infinitely**, leading to `**StackOverflowError**`.
    
    ---
    
    ## **2Ô∏è‚É£ Scenario That Causes the Issue**
    
    ### **Step 1: Entity Setup**
    
    ### **Department Entity**
    
    ```Java
    java
    CopyEdit
    @Entity
    public class Department {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne
        @JoinColumn(name = "manager_id")  // By default, FetchType.EAGER
        private Employee manager; // Circular reference with Employee
    
        // Getters and Setters
    }
    
    ```
    
    ### **Employee Entity**
    
    ```Java
    
    @Entity
    public class Employee {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne(mappedBy = "manager") // By default, FetchType.EAGER
        private Department department; // Circular reference with Department
    
        // Getters and Setters
    }
    
    ```
    
    ---
    
    ### **Step 2: REST Controller Without DTO**
    
    ```Java
    
    @RestController
    @RequestMapping("/departments")
    public class DepartmentController {
    
        @Autowired
        private DepartmentRepository departmentRepository;
    
        @GetMapping("/{id}")
        public Department getDepartment(@PathVariable Long id) {
            return departmentRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Department not found"));
        }
    }
    
    ```
    
    üö® **Issue:**
    
    - The response returns a **Department object**, which contains `manager (Employee)`.
    - `Employee` contains `department`, which again contains `manager`...
    - **Infinite recursion happens**, causing a `StackOverflowError`.
    
    ---
    
    ### **Step 3: The Problematic JSON Response**
    
    If a request is made to:
    
    ```Plain
    bash
    CopyEdit
    GET /departments/1
    
    ```
    
    The expected JSON response **should be**:
    
    ```JSON
    
    {
        "id": 1,
        "name": "IT Department",
        "manager": {
            "id": 100,
            "name": "John Doe"
        }
    }
    
    ```
    
    üö® **But in reality, the response never completes because of infinite recursion:**
    
    ```JSON
    
    {
        "id": 1,
        "name": "IT Department",
        "manager": {
            "id": 100,
            "name": "John Doe",
            "department": {
                "id": 1,
                "name": "IT Department",
                "manager": {
                    "id": 100,
                    "name": "John Doe",
                    "department": {
                        "id": 1,
                        "name": "IT Department",
                        "manager": { ... infinite recursion }
                    }
                }
            }
        }
    }
    
    ```
    
    üìå **This leads to a** `**StackOverflowError**` **because the objects keep referencing each other indefinitely!**
    
    ---
    
    ## **3Ô∏è‚É£ Solutions to Avoid Infinite Recursion**
    
    ### **‚úÖ Solution 1: Use** `**@JsonManagedReference**` **and** `**@JsonBackReference**`
    
    This approach **breaks the infinite loop** by ensuring only one direction is serialized.
    
    ### **Updated Department Entity**
    
    ```Java
    java
    CopyEdit
    @Entity
    public class Department {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne
        @JoinColumn(name = "manager_id")
        @JsonManagedReference  // Manages serialization
        private Employee manager;
    }
    
    ```
    
    ### **Updated Employee Entity**
    
    ```Java
    java
    CopyEdit
    @Entity
    public class Employee {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToOne(mappedBy = "manager")
        @JsonBackReference  // Prevents infinite recursion
        private Department department;
    }
    
    ```
    
    ‚úÖ **Now, when serializing** `**Department**`**, it includes** `**manager (Employee)**`**, but does NOT serialize** `**department**` **inside** `**Employee**`**, breaking the recursion.**
    
    ---
    
    ### **‚úÖ Solution 2: Use** `**@JsonIgnore**` **to Prevent Recursion**
    
    Another simple solution is to **ignore one side** of the relationship.
    
    ### **Updated Employee Entity**
    
    ```Java
    @OneToOne(mappedBy = "manager")
    @JsonIgnore // Prevents serialization of department inside Employee
    private Department department;
    
    ```
    
    ‚úÖ **This ensures** `**Employee**` **never serializes** `**department**`**, avoiding recursion.**
    
    üö® **Downside:** If you ever need to fetch `Employee.department`, it won‚Äôt be included in the response.
    
    ---
    
    ### **‚úÖ Solution 3: Use** `**FetchType.LAZY**` **Instead of** `**EAGER**`
    
    Changing the fetch type **prevents unnecessary loading** but does NOT fix the recursion alone.
    
    ```Java
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id")
    private Employee manager;
    
    ```
    
    üö® **Warning:** This prevents **automatic loading**, but serialization can still cause recursion.
    
    **Combine it with** `**@JsonIgnore**` **or DTOs for a complete fix!**
    
    ---
    
    ### **‚úÖ Solution 4: Use DTOs Instead of Direct Entity Serialization**
    
    A **better design approach** is to **never return entities in REST APIs** but use **DTOs**.
    
    ### **Create a DTO Class**
    
    ```Java
    java
    CopyEdit
    public class DepartmentDTO {
        private Long id;
        private String name;
        private String managerName;
    
        public DepartmentDTO(Department department) {
            this.id = department.getId();
            this.name = department.getName();
            this.managerName = department.getManager() != null ? department.getManager().getName() : null;
        }
    }
    
    ```
    
    ### **Modify Controller to Use DTO**
    
    ```Java
    java
    CopyEdit
    @RestController
    @RequestMapping("/departments")
    public class DepartmentController {
    
        @Autowired
        private DepartmentRepository departmentRepository;
    
        @GetMapping("/{id}")
        public DepartmentDTO getDepartment(@PathVariable Long id) {
            Department department = departmentRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Department not found"));
            return new DepartmentDTO(department);
        }
    }
    
    ```
    
    ‚úÖ **Now, recursion is completely avoided because only selected fields are included in the response.**
    
    ---
    
    ## **4Ô∏è‚É£ Updated Questionnaire for Interview**
    
    |   |   |   |
    |---|---|---|
    |Question|Problem Without Fix|Solution|
    |**Will an infinite recursion occur in bidirectional** `**@OneToOne**` **relationships?**|Yes, because `Department ‚Üí Employee ‚Üí Department ‚Üí Employee...` leads to `StackOverflowError`.|Use `@JsonManagedReference` / `@JsonBackReference`, `@JsonIgnore`, or DTOs.|
    |**How does returning an entity in a Spring Boot REST API cause recursion?**|When `Department` and `Employee` reference each other, serialization tries to serialize both indefinitely.|Break recursion using annotations or DTOs.|
    |**Why does changing** `**FetchType.LAZY**` **not completely fix the recursion?**|LAZY prevents automatic loading but doesn‚Äôt change JSON serialization behavior.|Use `@JsonIgnore` or DTOs to control serialization.|
    |**What‚Äôs the best way to avoid infinite recursion in REST APIs?**|Returning full entities exposes all relationships, causing recursion.|Use DTOs instead of returning entities directly.|
    
    ---
    
    ### **Final Takeaways**
    
    - **By default,** `**@OneToOne**` **fetches EAGERLY**, leading to recursion in bidirectional relationships.
    - **If entities are returned in REST APIs, infinite loops can occur** due to serialization.
    - **Fix it using** `**@JsonManagedReference**` **/** `**@JsonBackReference**`**,** `**@JsonIgnore**`**, or DTOs.**
    - **Best practice: Use DTOs instead of returning entities directly.**

  

  

```Java
DepartmentEntity departmentEntity = employeeEntity.map(
    employee -> employee.getManagedDepartment()
).orElse(null);

```

- In the above reference code, IntelliJ IDEA suggests that "the lambda can be replaced with a method reference."  
    > What does this mean?  
    > What is the **benefit** of using a method reference?  
    > What was the **initial problem**, and how does using a method reference improve it?  
      
      
    
    ### **1Ô∏è‚É£ Understanding the Initial Code with Lambda**
    
    - `employeeEntity` is an `Optional<EmployeeEntity>`.
    - `map(employee -> employee.getManagedDepartment())` applies `getManagedDepartment()` to the `EmployeeEntity` if present.
    - If `employeeEntity` is empty, `orElse(null)` returns `null`.
    
    ---
    
    ### **2Ô∏è‚É£ What Does "Can Be Replaced with Method Reference" Mean?**
    
    Instead of using a lambda like:
    
    ```Java
    employee -> employee.getManagedDepartment()
    ```
    
    You can **replace it with a method reference**:
    
    ```Java
    DepartmentEntity departmentEntity = employeeEntity.map(EmployeeEntity::getManagedDepartment).orElse(null);
    ```
    
    üìå **Why is this possible?**
    
    - The lambda expression `employee -> employee.getManagedDepartment()` **is just calling an instance method on an object**.
    - The `map()` function expects a **Function<T, R>**, which is exactly what `EmployeeEntity::getManagedDepartment` represents.
    
    ‚úÖ **So, IntelliJ suggests replacing it with a method reference for cleaner code.**
    
    ---
    
    ### **3Ô∏è‚É£ What Is the Benefit of Using Method Reference?**
    
    |   |   |   |
    |---|---|---|
    |Feature|Lambda (`->`)|Method Reference (`::`)|
    |**Readability**|Slightly verbose|More concise|
    |**Performance**|Same performance|Same performance|
    |**Code Simplicity**|Requires extra syntax|Direct method reference|
    |**Maintainability**|Might be unclear in large lambdas|More readable|
    
    üîπ **Main Benefit**: Method references **make code cleaner, more readable, and concise** without affecting performance.
    
    ---
    
    ### **4Ô∏è‚É£ When Should You Use Method References?**
    
    - **If a lambda just calls a method**, use a method reference.
    - Example **(Use method reference)**:
        
        ```Java
        list.forEach(System.out::println); // Instead of list.forEach(s -> System.out.println(s));
        ```
        
    - Example **(Lambdas are needed when extra logic is required)**:
        
        ```Java
        list.forEach(s -> {
            String formatted = "[" + s + "]";
            System.out.println(formatted);
        });
        
        ```
        
    
    ---
    
    ### **5Ô∏è‚É£ Final Answer:**
    
    - **Problem:** The lambda expression `employee -> employee.getManagedDepartment()` is unnecessarily verbose.
    - **Solution:** Replace it with `EmployeeEntity::getManagedDepartment`, making the code **more concise and readable**.
    - **Advantage:** Method references improve **code simplicity** and **readability** without performance loss.

  
  

- What is the `@Builder` annotation in Java?  
    Why do we use it?  
    What are the **benefits** of using it?  
    What **problem does it solve**?  
    How does it work in the below reference code where  
    `@Builder` is used in `EmployeeEntity.java`?  
      
    
    ### **1Ô∏è‚É£ What is** `**@Builder**`**?**
    
    `@Builder` is a **Lombok annotation** that **automatically generates** a **Builder pattern** for your class.
    
    üìå **It allows you to create objects in a more flexible and readable way** without needing a complex constructor.
    
    ‚úÖ **Example of** `**@Builder**` **in EmployeeEntity.java**
    
    ### **Reference Code:**
    
    ```Java
    
    import lombok.Builder;
    import lombok.Data;
    
    @Data
    @Builder
    public class EmployeeEntity {
        private Long id;
        private String name;
        private String position;
    }
    ```
    
    üìå **What this does:**
    
    - `@Data` generates **getters, setters,** `**toString()**`**,** `**equals()**`**, and** `**hashCode()**`.
    - `@Builder` **creates a builder pattern** for constructing objects.
    
    ---
    
    ### **2Ô∏è‚É£ Problem Without** `**@Builder**`
    
    Before `@Builder`, you had to **manually write constructors** or use **setters**:
    
    ```Java
    EmployeeEntity employee = new EmployeeEntity();
    employee.setId(1L);
    employee.setName("John Doe");
    employee.setPosition("Manager");
    ```
    
    üö® **Problems:**
    
    - Too **many setter calls**, making the code **less readable**.
    - **Immutable objects** are difficult to create.
    
    ---
    
    ### **3Ô∏è‚É£ Solution: Using** `**@Builder**`
    
    With `@Builder`, object creation is **cleaner and more readable**:
    
    ```Java
    EmployeeEntity employee = EmployeeEntity.builder()
            .id(1L)
            .name("John Doe")
            .position("Manager")
            .build();
    ```
    
    ‚úÖ **Benefits of using** `**@Builder**`
    
    |   |   |
    |---|---|
    |Problem Without `@Builder`|Solution With `@Builder`|
    |Requires **multiple setter calls**|Uses **chained method calls**, making it cleaner|
    |**Immutable objects** are hard to create|**No need for setters**, fields can be final|
    |Hard to **track parameter order** in constructors|Named methods (`.id()`, `.name()`) improve clarity|
    
    ---
    
    ### **4Ô∏è‚É£ What Problem Does** `**@Builder**` **Solve?**
    
    |   |   |
    |---|---|
    |Problem|How `@Builder` Solves It|
    |**Too many setter calls make object creation messy**|Allows **chained, readable** object creation|
    |**Constructors with many arguments are confusing**|Avoids **long constructors**, making code **clearer**|
    |**Immutable objects require complex logic**|Works well with `@AllArgsConstructor` and `@Value`|
    
    ---
    
    ### **5Ô∏è‚É£ How Does** `**@Builder**` **Work Internally?**
    
    When you add `@Builder`, Lombok **generates a static inner Builder class** like this:
    
    ```Java
    public class EmployeeEntity {
        private Long id;
        private String name;
        private String position;
    
        public static class EmployeeEntityBuilder {
            private Long id;
            private String name;
            private String position;
    
            public EmployeeEntityBuilder id(Long id) {
                this.id = id;
                return this;
            }
    
            public EmployeeEntityBuilder name(String name) {
                this.name = name;
                return this;
            }
    
            public EmployeeEntityBuilder position(String position) {
                this.position = position;
                return this;
            }
    
            public EmployeeEntity build() {
                return new EmployeeEntity(id, name, position);
            }
        }
    
        public static EmployeeEntityBuilder builder() {
            return new EmployeeEntityBuilder();
        }
    }
    
    ```
    
    üìå **Instead of writing this manually,** `**@Builder**` **generates it automatically!**
    
    ---
    
    ### **6Ô∏è‚É£ Can** `**@Builder**` **Work with Constructors?**
    
    Yes! If your class has a **constructor**, `@Builder` works seamlessly:
    
    ```Java
    @Data
    @Builder
    @AllArgsConstructor
    public class EmployeeEntity {
        private final Long id;
        private final String name;
        private final String position;
    }
    
    ```
    
    ‚úÖ **Now, fields can be** `**final**`**, making the class immutable.**
    
    ---
    
    ### **7Ô∏è‚É£ Summary**
    
    |   |   |   |
    |---|---|---|
    |Feature|Without `@Builder`|With `@Builder`|
    |Object Creation|Requires **setters** or **long constructors**|Uses **chained method calls**|
    |Code Readability|Harder to read|More **structured and clean**|
    |Immutability|Difficult to enforce|Works well with `final` fields|
    |Constructor Overload|Multiple constructors required|No need for multiple constructors|
    
    ---
    
    ### **8Ô∏è‚É£ Final Answer**
    
    - `@Builder` in `EmployeeEntity.java` **automatically generates the Builder pattern**, making object creation **easier and cleaner**.
    - **Problem it solves:** Avoids **setters**, makes objects **immutable**, and improves **readability**.
    - **How it works:** It **creates a Builder class internally**, allowing **chained method calls**.
    - **Best use case:** When you need to **construct objects in a flexible, readable way**.