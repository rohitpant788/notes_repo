## **üì¢ Why Transform API Responses?**

Currently, we are directly returning objects from our controllers without any transformation. However, in **production-ready** applications, API responses must follow a **consistent format** to ensure seamless integration with the **frontend**.

‚úÖ **Problems with unstructured responses:**

- No uniform structure across APIs.
- Frontend developers must handle different response formats.
- Error responses and success responses may differ drastically.

‚úÖ **Solution: Implementing a Global API Response Format**

- We can **transform API responses globally** so that all responses follow a single structure.
- This eliminates the need to manually transform each API response.
- We use `**@RestControllerAdvice**` along with `**ResponseBodyAdvice<T>**` to achieve this.

---

## **üõ†Ô∏è Implementing Global API Response Handling**

### **Step 1: Create a Global Response Handler**

We will create a class `**GlobalResponseHandler**` to **intercept and modify** all API responses.

### **üìå Code: GlobalResponseHandler.java**

```Java

@RestControllerAdvice
public class GlobalResponseHandler implements ResponseBodyAdvice<Object> {

    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // Always return true to apply this transformation to all responses.
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                  Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        // If response is already of type APIResponse, return it as is
        if (body instanceof APIResponse) {
            return body;
        }
        // Otherwise, wrap it in an APIResponse object
        return new APIResponse<>(body);
    }
}

```

### **üöÄ Explanation:**

1. `**supports()**` - This method ensures the transformation applies to **all** API responses.
2. `**beforeBodyWrite()**` - This method **wraps every API response** inside an `APIResponse<T>` object.

---

## **üõ†Ô∏è Step 2: Create a Wrapper Class for API Responses**

To maintain consistency, we define a **generic API response class** that includes:

- `**data**` field for successful responses.
- `**error**` field for failed responses.
- `**timestamp**` to log when the response was generated.

### **üìå Code: APIResponse.java**

```Java
java
CopyEdit
public class APIResponse<T> {
    private T data;
    private APIError error;
    private LocalDateTime timestamp;

    // Constructor for success responses
    public APIResponse(T data) {
        this.data = data;
        this.timestamp = LocalDateTime.now();
    }

    // Constructor for error responses
    public APIResponse(APIError error) {
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }

    // Getters
    public T getData() { return data; }
    public APIError getError() { return error; }
    public LocalDateTime getTimestamp() { return timestamp; }
}

```

### **üöÄ Explanation:**

- Uses **generics (**`**T**`**)** to support any data type.
- Has **constructors** for both **success** and **error** responses.
- Includes a **timestamp** for logging.

---

## **üõ†Ô∏è Step 3: Handling API Errors**

### **üìå Code: APIError.java**

```Java
java
CopyEdit
public class APIError {
    private String message;
    private HttpStatus status;
    private List<String> errors;

    public APIError(HttpStatus status, String message, List<String> errors) {
        this.status = status;
        this.message = message;
        this.errors = errors;
    }

    // Getters
    public String getMessage() { return message; }
    public HttpStatus getStatus() { return status; }
    public List<String> getErrors() { return errors; }
}

```

### **üöÄ Explanation:**

- Stores **error message, HTTP status, and a list of validation errors**.
- Makes it easy for frontend teams to understand error details.

---

## **üõ†Ô∏è Step 4: Modifying Global Exception Handling**

Now, we modify our **GlobalExceptionHandler** to return errors in the new API format.

### **üìå Code: GlobalExceptionHandler.java**

```Java
java
CopyEdit
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<APIResponse<?>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<String> errors = ex.getBindingResult().getAllErrors()
                .stream()
                .map(ObjectError::getDefaultMessage)
                .collect(Collectors.toList());

        APIError apiError = new APIError(HttpStatus.BAD_REQUEST, "Validation Failed", errors);
        return new ResponseEntity<>(new APIResponse<>(apiError), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<APIResponse<?>> handleGeneralException(Exception ex) {
        APIError apiError = new APIError(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage(), Collections.emptyList());
        return new ResponseEntity<>(new APIResponse<>(apiError), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

```

### **üöÄ Explanation:**

- **Handles validation errors** (`MethodArgumentNotValidException`).
- **Handles all other exceptions** (`Exception`).
- Returns **errors wrapped in the APIResponse format**.

---

## **üõ†Ô∏è Step 5: Customizing Timestamp Format**

By default, `LocalDateTime` uses **UTC format (TZ format)**. We can format it differently using **Jackson annotations**.

### **üìå Code: APIResponse.java (with timestamp formatting)**

```Java
java
CopyEdit
import com.fasterxml.jackson.annotation.JsonFormat;

public class APIResponse<T> {
    private T data;
    private APIError error;

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "HH:mm:ss dd-MM-yyyy")
    private LocalDateTime timestamp;

    public APIResponse(T data) {
        this.data = data;
        this.timestamp = LocalDateTime.now();
    }

    public APIResponse(APIError error) {
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}

```

### **üöÄ Explanation:**

- Formats timestamp as **HH:mm:ss dd-MM-yyyy**.

---

## **üõ†Ô∏è Testing the Implementation**

Let's test our implementation using **Postman**.

### ‚úÖ **Success Response:**

### **Request:**

```JSON
json
CopyEdit
GET /api/users

```

### **Response:**

```JSON
json
CopyEdit
{
    "data": [
        { "id": 1, "name": "John Doe", "email": "john@example.com" },
        { "id": 2, "name": "Jane Doe", "email": "jane@example.com" }
    ],
    "error": null,
    "timestamp": "14:30:25 15-02-2025"
}

```

### ‚ùå **Error Response (Validation Failure):**

### **Request:**

```JSON
json
CopyEdit
POST /api/users
{
    "name": ""
}

```

### **Response:**

```JSON
json
CopyEdit
{
    "data": null,
    "error": {
        "message": "Validation Failed",
        "status": "BAD_REQUEST",
        "errors": ["Name field cannot be empty"]
    },
    "timestamp": "14:31:10 15-02-2025"
}

```

---

## **üìå Summary: Key Takeaways**

‚úÖ **Why Transform API Responses?**

- Ensures **consistent API response format**.
- Helps frontend developers handle responses easily.
- Makes debugging and error tracking easier.

‚úÖ **How We Implemented It?**

1. **Used** `**ResponseBodyAdvice<T>**` **to globally modify API responses**.
2. **Created** `**APIResponse<T>**` **to wrap all responses**.
3. **Created** `**APIError**` **to standardize error responses**.
4. **Modified** `**GlobalExceptionHandler**` **to return structured errors**.
5. **Formatted** `**timestamp**` **using Jackson for better readability**.

‚úÖ **Advantages**

- **Standardized success & error responses**.
- **Easier debugging** with timestamps.
- **Easier frontend integration**.

---