## **Introduction**

Exception handling is a crucial aspect of any application. In Spring Boot MVC, understanding how to handle exceptions properly ensures a smooth user experience and prevents application crashes.

Before diving into Spring Boot exception handling, it's essential to have a strong understanding of core Java exception handling, including:

- Creating custom exceptions.
- Throwing exceptions.
- Catching exceptions using `try-catch`.

This guide covers **exception handling in Spring Boot MVC** in a structured manner.

---

## **Why Do We Need Exception Handling?**

### **1. Preventing Application Crashes**

- If exceptions are not handled, the application may crash.
- Example: A **divide by zero error** can lead to a runtime exception.
- Solution: Use a **try-catch block** to gracefully handle errors.

### **2. Providing User-Friendly Error Responses**

- When users pass invalid input, they should receive a meaningful message.
- Example: If a user tries to fetch an employee by ID that doesnâ€™t exist, they should receive a **404 Not Found** response instead of a generic error.

### **3. Facilitating Debugging and Maintenance**

- Logging errors helps developers debug issues effectively.
- Developers can track errors from logs and fix them before they escalate.

### **4. Ensuring Consistent Error Handling Across the Application**

- A uniform error-handling mechanism makes it easier for frontend developers to understand and process errors correctly.

---

## **Exception Handling in Spring Boot MVC**

Spring Boot provides various ways to handle exceptions:

1. **Using** `**@ExceptionHandler**` **(Controller-Level Exception Handling)**
2. **Using** `**@RestControllerAdvice**` **(Global Exception Handling)**
3. **Creating Custom Exceptions**
4. **Handling Validation Errors Gracefully**

Let's explore each approach step by step.

---

## **1. Handling Exceptions at the Controller Level (**`**@ExceptionHandler**`**)**

The `@ExceptionHandler` annotation allows us to handle exceptions within a specific controller.

### **Example: Handling "Employee Not Found" Exception**

```Java
java
CopyEdit
@Controller
public class EmployeeController {

    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<String> handleEmployeeNotFound(NoSuchElementException ex) {
        return new ResponseEntity<>("Employee was not found", HttpStatus.NOT_FOUND);
    }

    @GetMapping("/employees/{id}")
    public EmployeeDTO getEmployeeById(@PathVariable Long id) {
        return employeeService.getEmployeeById(id)
                .orElseThrow(() -> new NoSuchElementException("Employee not found"));
    }
}

```

### **Explanation:**

- If an **employee is not found**, a `NoSuchElementException` is thrown.
- The `handleEmployeeNotFound` method **intercepts the exception** and returns a **404 Not Found** response.

### **Problem With This Approach**

- It works **only within this controller**.
- If we have multiple controllers, we need to **duplicate the exception handling logic**.

---

## **2. Handling Exceptions Globally (**`**@RestControllerAdvice**`**)**

Instead of handling exceptions in individual controllers, we can create a **global exception handler**.

### **Step 1: Create a Global Exception Handler**

```Java
java
CopyEdit
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiError> handleResourceNotFound(ResourceNotFoundException ex) {
        ApiError error = new ApiError(HttpStatus.NOT_FOUND, ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
}

```

### **Step 2: Create a Custom Exception**

```Java
java
CopyEdit
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

```

### **Step 3: Modify Controller to Use Custom Exception**

```Java
java
CopyEdit
@GetMapping("/employees/{id}")
public EmployeeDTO getEmployeeById(@PathVariable Long id) {
    return employeeService.getEmployeeById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Employee not found"));
}

```

### **Why is this better?**

- Exception handling is **centralized**.
- Works for **all controllers** in the application.
- Ensures **consistent error messages**.

---

## **3. Creating a Custom Error Response**

Instead of returning plain text error messages, we should return a structured **JSON response**.

### **Step 1: Create an** `**ApiError**` **Class**

```Java
java
CopyEdit
@Data
@Builder
public class ApiError {
    private HttpStatus status;
    private String message;
}

```

### **Step 2: Modify the Exception Handler to Use** `**ApiError**`

```Java

@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ApiError> handleResourceNotFound(ResourceNotFoundException ex) {
    ApiError error = ApiError.builder()
            .status(HttpStatus.NOT_FOUND)
            .message(ex.getMessage())
            .build();
    return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
}

```

### **Now, the error response will look like this:**

```JSON

{
    "status": "NOT_FOUND",
    "message": "Employee not found"
}

```

---

## **4. Handling Validation Errors**

Spring Boot provides built-in validation using `@Valid` and `@Validated`.

### **Step 1: Apply Validation to DTO**

```Java
java
CopyEdit
public class EmployeeDTO {

    @NotNull(message = "Name cannot be null")
    @Size(min = 3, message = "Name should have at least 3 characters")
    private String name;

    @Min(value = 18, message = "Age must be at least 18")
    private int age;
}

```

### **Step 2: Handle Validation Errors in** `**GlobalExceptionHandler**`

```Java

@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<ApiError> handleValidationErrors(MethodArgumentNotValidException ex) {
    List<String> errors = ex.getBindingResult().getAllErrors()
            .stream()
            .map(DefaultMessageSourceResolvable::getDefaultMessage)
            .collect(Collectors.toList());

    ApiError error = ApiError.builder()
            .status(HttpStatus.BAD_REQUEST)
            .message("Input validation failed")
            .subErrors(errors)
            .build();
    return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
}

```

### **Error Response Example:**

```JSON

{
    "status": "BAD_REQUEST",
    "message": "Input validation failed",
    "subErrors": [
        "Name should have at least 3 characters",
        "Age must be at least 18"
    ]
}

```

---

## **5. Handling All Other Exceptions**

To handle all unexpected exceptions, we create a generic exception handler:

```Java

@ExceptionHandler(Exception.class)
public ResponseEntity<ApiError> handleAllExceptions(Exception ex) {
    ApiError error = ApiError.builder()
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .message("An unexpected error occurred: " + ex.getMessage())
            .build();
    return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
}

```

---

## **Summary**

|   |   |
|---|---|
|**Feature**|**Implementation**|
|**Controller-Level Handling**|`@ExceptionHandler` in a controller.|
|**Global Exception Handling**|`@RestControllerAdvice` for centralized handling.|
|**Custom Exception**|`ResourceNotFoundException` for meaningful errors.|
|**Structured Error Response**|Use `ApiError` class for detailed responses.|
|**Validation Error Handling**|`@Valid` annotation and `MethodArgumentNotValidException` handler.|
|**Handling All Exceptions**|A generic `Exception.class` handler for unknown errors.|

---

## **Key Takeaways for Interviews**

1. **How does Spring Boot handle exceptions?**
    - Using `@ExceptionHandler`, `@RestControllerAdvice`, and custom exception classes.
2. **Why use a global exception handler?**
    - Ensures uniform error responses across all controllers.
3. **How to return structured JSON error responses?**
    - Use a custom `ApiError` class.
4. **How to handle validation errors?**
    - Use `@Valid` annotation and `MethodArgumentNotValidException` handler.

---