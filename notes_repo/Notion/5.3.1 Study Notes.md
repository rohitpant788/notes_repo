## üìå **Introduction**

In the previous session, we discussed the **internal workings of Spring Security**. Today, we will **dive deeper** into the security flow and examine the code-level details to fully understand authentication in Spring Boot.

---

## **üîπ Recap: Spring Security Authentication Flow**

### üìç **Authentication Request Flow**

1Ô∏è‚É£ **Client sends authentication request**

- When Spring Security is configured, an **auto-configuration process** registers a **security filter chain** inside the existing filter chain.
- Every authentication request **first goes through the security filter chain** before reaching the authentication mechanism.

2Ô∏è‚É£ **Authentication request is passed to Authentication Manager**

- The **Authentication Manager** is responsible for verifying user authentication requests.
- It delegates authentication to **one or more Authentication Providers**.

3Ô∏è‚É£ **Authentication Providers handle different authentication methods**

- **DAO Authentication Provider**: Handles **username & password-based authentication**.
- **OAuth2 Authentication Provider**: Handles authentication via **Google, Facebook, GitHub, etc.**
- **In-Memory Authentication Provider**: Fetches user details from memory.

4Ô∏è‚É£ **DAO Authentication Provider fetches user details**

- It interacts with **UserDetailsService** to fetch **username, hashed password, and authorities** from the database.
- Password is compared using **Password Encoder**.

5Ô∏è‚É£ **User is authenticated and stored in Security Context**

- If authentication is successful, the **Security Context Holder** stores the authenticated user details.
- All subsequent requests use this authenticated user.

---

## **üîπ Spring Security Filter Chain**

The below **diagram illustrates how Spring Security integrates with the Servlet filter chain.**

![[image.png]]

‚úîÔ∏è **Spring Security Filter Chain Breakdown**:

- Requests first pass through **Servlet Filters**.
- `DelegatingFilterProxy` ensures that **Spring Security's** `**FilterChainProxy**` **is invoked**.
- `FilterChainProxy` processes multiple security-related filters, including:
    - `CorsFilter`
    - `CsrfFilter`
    - `LogoutFilter`
    - `UsernamePasswordAuthenticationFilter`
    - `BearerTokenAuthenticationFilter`

---

## **üîπ Step-by-Step Deep Dive into Authentication Flow**

### **üìç 1. Authentication Request Handling**

‚úîÔ∏è **Client logs in** ‚Üí Request reaches the **Security Filter Chain** ‚Üí Passed to **Authentication Manager**

‚úîÔ∏è **Authentication Manager** is an **interface** that contains the `authenticate()` method.

‚úîÔ∏è Inside the login controller:

```Java

Authentication auth = new UsernamePasswordAuthenticationToken(email, password);
Authentication authenticatedUser = authenticationManager.authenticate(auth);
```

‚úîÔ∏è The `authenticate()` method receives an authentication object, which is initially **not authenticated**.

---

### **üìç 2. Authentication Manager & Provider Manager**

‚úîÔ∏è **Authentication Manager** is implemented by `ProviderManager`.

‚úîÔ∏è `ProviderManager` maintains a **list of Authentication Providers**.

‚úîÔ∏è It iterates over **each authentication provider** to find a suitable one.

```Java
java
CopyEdit
for (AuthenticationProvider provider : providers) {
    if (provider.supports(auth.getClass())) {
        return provider.authenticate(auth);
    }
}

```

‚úîÔ∏è If a provider **supports** the request, it will handle authentication.

---

### **üìç 3. Authentication Providers (DAO, OAuth2, In-Memory)**

‚úîÔ∏è `AuthenticationProvider` is an interface implemented by multiple classes:

- **DAO Authentication Provider** ‚Üí Uses `UserDetailsService`
- **OAuth2 Authentication Provider** ‚Üí Uses `OIDC`
- **In-Memory Authentication Provider** ‚Üí Uses predefined users

‚úîÔ∏è `DAOAuthenticationProvider` authenticates **username/password-based requests**.

```Java
UserDetails userDetails = userDetailsService.loadUserByUsername(username);
```

‚úîÔ∏è If the **password matches**, authentication succeeds.

---

### **üìç 4. UserDetailsService & User Entity**

‚úîÔ∏è `UserDetailsService` fetches user details from **database or memory**.  
‚úîÔ∏è  
`UserDetails` is an **interface** with:

- `getUsername()`
- `getPassword()`
- `getAuthorities()`

‚úîÔ∏è **Implementing** `**UserDetailsService**`

```Java

@Service
public class UserService implements UserDetailsService {
    private final UserRepository userRepository;

    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        return userRepository.findByEmail(email)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }
}
```

‚úîÔ∏è **Creating User Entity**

```Java
java
CopyEdit
@Entity
public class User implements UserDetails {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String email;
    private String password;

    @Override
    public String getUsername() { return email; }
    @Override
    public String getPassword() { return password; }
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() { return List.of(); }
}

```

---

### **üìç 5. Password Encoding for Security**

‚úîÔ∏è **Passwords must always be stored in an encoded format** to prevent exposure.  
‚úîÔ∏è **Password Encoders available in Spring Security:**

- `BCryptPasswordEncoder`
- `SCryptPasswordEncoder`
- `Pbkdf2PasswordEncoder`

‚úîÔ∏è **Encoding and Matching Passwords**

```Java
PasswordEncoder encoder = new BCryptPasswordEncoder();
String encodedPassword = encoder.encode("password123");

boolean matches = encoder.matches("password123", encodedPassword);
```

‚úîÔ∏è The system **compares the hashed password from the request** with the **stored hash**.

---

### **üìç 6. Authentication Flow Diagram**

![[image 1.png]]

‚úîÔ∏è **Spring Security Authentication Flow Breakdown**:

- `AuthenticationManager` delegates authentication to `ProviderManager`.
- `ProviderManager` loops through `AuthenticationProviders`.
- `DaoAuthenticationProvider` fetches user details from `UserDetailsService`.
- `PasswordEncoder` encodes & matches passwords.
- Authenticated user is stored in `SecurityContextHolder`.

---

## **üîπ Core Components of Spring Security**

|   |   |
|---|---|
|Component|Description|
|**UserDetails**|Interface containing `getUsername()`, `getPassword()`, `getAuthorities()`|
|**UserDetailsService**|Interface for fetching user data from database/memory|
|**AuthenticationManager**|Interface managing authentication requests|
|**ProviderManager**|Implements `AuthenticationManager`, maintains a list of `AuthenticationProvider`|
|**DAOAuthenticationProvider**|Handles username/password-based authentication|
|**OAuth2AuthenticationProvider**|Handles authentication via Google, Facebook, etc.|
|**PasswordEncoder**|Securely hashes passwords before storing|
|**SecurityContextHolder**|Stores the authenticated user session|

---

## **üîπ Summary for Quick Revision**

‚úÖ **Authentication Flow:**

- Request ‚Üí `SecurityFilterChain` ‚Üí `AuthenticationManager` ‚Üí `ProviderManager` ‚Üí `DAOAuthenticationProvider` ‚Üí `UserDetailsService` ‚Üí `PasswordEncoder` ‚Üí `SecurityContextHolder`

‚úÖ **Key Interfaces & Implementations:**

- `AuthenticationManager` ‚Üí `ProviderManager`
- `AuthenticationProvider` ‚Üí `DAOAuthenticationProvider`
- `UserDetailsService` ‚Üí Fetches user from DB
- `UserDetails` ‚Üí Stores user info
- `PasswordEncoder` ‚Üí Hashes passwords

  

## **Final Summary: Authentication Flow in Spring Security**

|   |   |
|---|---|
|Step|Description|
|**1. User Login**|Client sends a login request with username & password|
|**2. Security Filters**|Request goes through Security Filter Chain (`UsernamePasswordAuthenticationFilter`)|
|**3. AuthenticationManager**|`AuthenticationManager` delegates authentication to `ProviderManager`|
|**4. ProviderManager**|`ProviderManager` iterates through `AuthenticationProviders`|
|**5. DaoAuthenticationProvider**|`DaoAuthenticationProvider` fetches user details via `UserDetailsService`|
|**6. UserDetailsService**|Retrieves user from **database/in-memory**|
|**7. Password Encoding**|Encodes & matches password using `PasswordEncoder`|
|**8. Authentication Success**|If successful, authenticated user is stored in `SecurityContextHolder`|
|**9. Access Secured Resources**|Authenticated user can access protected endpoints|

‚úÖ **Security Best Practices:**

- **Always hash passwords** before storing in the database.
- **Use a strong password encoder** like BCrypt.
- **Store authentication tokens securely** (JWT recommended).
- **Restrict access using roles & authorities**.

---