## **Understanding Different HTTP Mappings**

In this section, we will explore different HTTP mappings in Spring Boot, such as **PUT**, **PATCH**, and **DELETE**, and how to implement them following industry standards.

---

## **1. Recap of Layers in a Spring Boot Application**

- **Persistence Layer**: Handles database operations (Repository layer).
- **Service Layer**: Contains business logic.
- **Presentation Layer**: Handles HTTP requests (Controller layer).

### **Previously Implemented**

âœ” **GET Mapping** (Retrieve data)

âœ” **POST Mapping** (Create new data)

### **Now Implementing**

âœ” **PUT Mapping** (Update entire entity)

âœ” **PATCH Mapping** (Partially update entity)

âœ” **DELETE Mapping** (Remove entity)

---

## **2. PUT Mapping - Updating the Entire Entity**

### **When to use** `**@PutMapping**`**?**

- Used to update **the entire entity**.
- If an entity exists, it updates all its fields.
- If an entity doesnâ€™t exist, it creates a new one.

### **Example: Understanding PUT**

### **Scenario**

1. Employee **ID: 1** â†’ Name: **Ram**
2. **Updating** ID: 1 â†’ Name: **Shyam**
3. **Result**: Employee ID remains the same, but all data is replaced.

### **Implementation of PUT Mapping**

```Java

@PutMapping("/employees/{id}")
public ResponseEntity<EmployeeDTO> updateEmployeeById(
        @PathVariable Long id,
        @RequestBody EmployeeDTO employeeDTO) {

    EmployeeDTO updatedEmployee = employeeService.updateEmployeeById(id, employeeDTO);
    return ResponseEntity.ok(updatedEmployee);
}

```

- `@PutMapping("/employees/{id}")` â†’ Maps PUT requests.
- `@PathVariable Long id` â†’ Extracts ID from the URL.
- `@RequestBody EmployeeDTO employeeDTO` â†’ Extracts JSON data from the request body.
- Calls `updateEmployeeById(id, employeeDTO)` in the service layer.

### **Service Layer Implementation**

```Java

public EmployeeDTO updateEmployeeById(Long id, EmployeeDTO employeeDTO) {
    EmployeeEntity employeeEntity = modelMapper.map(employeeDTO, EmployeeEntity.class);
    employeeEntity.setId(id);  // Ensure ID is retained
    EmployeeEntity savedEntity = employeeRepository.save(employeeEntity);
    return modelMapper.map(savedEntity, EmployeeDTO.class);
}

```

**Behavior:**

- Converts `DTO` â†’ `Entity`
- Saves entity using `employeeRepository.save(employeeEntity)`.
- If an entity exists, updates it.
- If not, creates a new one.

---

## **3. PATCH Mapping - Partially Updating an Entity**

### **When to use** `**@PatchMapping**`**?**

- Used when only a few fields need to be updated.
- Prevents overwriting other fields.
- Accepts a **dynamic set of fields**.

### **Problem with PUT (Why PATCH is Needed?)**

```JSON
json
CopyEdit
{
  "name": "XYZ"
}

```

**Expected:** Only `name` updates.

**Issue with PUT:** Other fields (email, age, etc.) become `null`.

**Solution:** Use **PATCH** to update only provided fields.

### **Implementation of PATCH Mapping**

```Java
java
CopyEdit
@PatchMapping("/employees/{id}")
public ResponseEntity<EmployeeDTO> updatePartialEmployeeById(
        @PathVariable Long id,
        @RequestBody Map<String, Object> updates) {

    EmployeeDTO updatedEmployee = employeeService.updatePartialEmployeeById(id, updates);
    return updatedEmployee != null ? ResponseEntity.ok(updatedEmployee) : ResponseEntity.notFound().build();
}

```

- `@PatchMapping("/employees/{id}")` â†’ Maps PATCH requests.
- `@RequestBody Map<String, Object> updates` â†’ Allows dynamic updates.

### **Service Layer Implementation**

```Java
java
CopyEdit
public EmployeeDTO updatePartialEmployeeById(Long id, Map<String, Object> updates) {
    Optional<EmployeeEntity> optionalEmployee = employeeRepository.findById(id);

    if (optionalEmployee.isEmpty()) {
        return null;
    }

    EmployeeEntity employeeEntity = optionalEmployee.get();

    updates.forEach((key, value) -> {
        Field field = ReflectionUtils.findField(EmployeeEntity.class, key);
        if (field != null) {
            field.setAccessible(true);
            ReflectionUtils.setField(field, employeeEntity, value);
        }
    });

    EmployeeEntity savedEntity = employeeRepository.save(employeeEntity);
    return modelMapper.map(savedEntity, EmployeeDTO.class);
}

```

**Concepts Used:**  
âœ”  
`ReflectionUtils.findField()` â†’ Dynamically finds fields.

âœ” `ReflectionUtils.setField()` â†’ Updates fields dynamically.

---

## **4. DELETE Mapping - Removing an Entity**

### **When to use** `**@DeleteMapping**`**?**

- Used to remove an entity from the database.

### **Implementation of DELETE Mapping**

```Java

@DeleteMapping("/employees/{id}")
public ResponseEntity<Boolean> deleteEmployeeById(@PathVariable Long id) {
    boolean deleted = employeeService.deleteEmployeeById(id);
    return deleted ? ResponseEntity.ok(true) : ResponseEntity.notFound().build();
}

```

- Calls `deleteEmployeeById(id)` in the service layer.

### **Service Layer Implementation**

```Java

public boolean deleteEmployeeById(Long id) {
    if (!employeeRepository.existsById(id)) {
        return false;
    }
    employeeRepository.deleteById(id);
    return true;
}

```

- `**existsById(id)**` â†’ Checks if the employee exists.
- `**deleteById(id)**` â†’ Deletes the employee.

---

## **5. Handling HTTP Status Codes Properly**

Instead of returning raw objects, **ResponseEntity** should be used to return proper HTTP status codes.

### **Response Status Codes**

|   |   |
|---|---|
|Status Code|Meaning|
|`200 OK`|Successful request|
|`201 Created`|Resource created successfully|
|`404 Not Found`|Resource not found|
|`500 Internal Server Error`|Server-side issue|

### **Using ResponseEntity**

```Java

public ResponseEntity<EmployeeDTO> getEmployeeById(Long id) {
    Optional<EmployeeDTO> optionalEmployee = employeeRepository.findById(id)
        .map(employee -> modelMapper.map(employee, EmployeeDTO.class));

    return optionalEmployee.map(ResponseEntity::ok)
        .orElseGet(() -> ResponseEntity.notFound().build());
}

```

- If employee exists â†’ Returns `200 OK`.
- If not found â†’ Returns `404 Not Found`.

---

## **6. Fixing Boolean Field Serialization Issue**

### **Problem:** `**isActive**` **Field Serialization**

- JSON by default doesnâ€™t recognize **isActive** correctly.
- Causes **serialization issues**.

### **Fix**

Use `@JsonProperty`:

```Java

@JsonProperty("is_active")
private boolean isActive;

```

- Ensures JSON recognizes it correctly.

### **Using Lombok for Getters/Setters**

Instead of manually writing getters/setters, use **Lombok**:

```Java

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class EmployeeDTO {
    private Long id;
    private String name;
    private String email;
    private int age;
    @JsonProperty("is_active")
    private boolean isActive;
}

```

- **Reduces Boilerplate Code**.
- **Handles Serialization Properly**.

---

## **7. Summary - Quick Revision Before Interview**

|   |   |
|---|---|
|Concept|Explanation|
|**GET Mapping**|Retrieve data (Single/All)|
|**POST Mapping**|Create new entity|
|**PUT Mapping**|Update entire entity (Creates if not exists)|
|**PATCH Mapping**|Partially update entity (Prevents data loss)|
|**DELETE Mapping**|Remove entity from DB|
|**ResponseEntity**|Handles HTTP status codes properly|
|**Reflection API**|Used in PATCH for dynamic field updates|
|**Lombok**|Simplifies getters, setters, constructors|
|**JsonProperty**|Fixes JSON serialization issues|
|**Exception Handling**|Not covered yet, but will handle errors gracefully|
|**Validation (Bean Validation)**|Upcoming topic for ensuring input correctness|

---

## **Next Steps**

- âœ… Implemented `PUT`, `PATCH`, and `DELETE` mappings.
- âœ… Optimized REST API using **ResponseEntity**.
- ðŸ”œ Next: **Exception Handling & Input Validation (Bean Validation)**.

These notes ensure you **never have to revisit the video** again! ðŸš€