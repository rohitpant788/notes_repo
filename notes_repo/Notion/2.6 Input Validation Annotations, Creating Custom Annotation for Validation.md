## **üìå Introduction**

- So far, we've seen how **CRUD operations** work with REST APIs in Spring Boot.
- Now, we focus on **validating input data** before it reaches the database.
- **Why is validation important?**
    - Prevents **invalid data** from being stored.
    - Ensures data **integrity** (e.g., email must be valid, date of birth should be in the past).
- **Key Concepts:**
    - **Built-in Spring Boot validations**
    - **Custom annotations for validation**
    - **Ensuring correctness of input at the DTO layer**

---

## **üìç Problem Statement**

- Currently, there‚Äôs **no restriction** on what data can be sent.
- Example:
    - A user can send `"email": "randomtext"` ‚Üí Stored in the DB.
    - We **don't want invalid** emails or names to be saved.
    - We should **reject bad input at the controller level** before reaching the service layer.

---

## **‚úÖ Adding Spring Boot Validation Dependency**

- To enable validation, we must **add the following dependency** in `pom.xml`:
    
    ```XML
    xml
    CopyEdit
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    
    ```
    
- After adding the dependency, **refresh Maven** to download it.

---

## **üìå Input Validation with Annotations**

- The **DTO (Data Transfer Object)** is the first entry point for validation.
- We can use various **Jakarta validation annotations** inside DTO classes.

### **Common Annotations**

|   |   |
|---|---|
|Annotation|Purpose|
|`@NotNull`|Field **cannot be null**|
|`@NotEmpty`|Field **cannot be empty** (for Strings, Collections, Arrays)|
|`@NotBlank`|Field **cannot be blank** (ignores spaces)|
|`@Size(min, max)`|Ensures the field's **length** falls within the range|
|`@Email`|Ensures a valid **email format**|
|`@Pattern(regex)`|Custom **regex validation**|
|`@Min(value)`|Ensures a number is **not smaller** than the given value|
|`@Max(value)`|Ensures a number is **not greater** than the given value|
|`@Past`|Ensures the date is **in the past**|
|`@Future`|Ensures the date is **in the future**|
|`@Positive`|Ensures number is **greater than zero**|
|`@Negative`|Ensures number is **less than zero**|
|`@Valid`|Recursively **validates nested objects**|

---

## **üìç Implementing Validation in Employee DTO**

### **Step 1: Apply Validation Annotations**

- Example **Employee DTO** with validation:
    
    ```Java
    java
    CopyEdit
    import jakarta.validation.constraints.*;
    
    public class EmployeeDTO {
    
        @NotBlank(message = "Name is required")
        @Size(min = 3, max = 10, message = "Number of characters in name should be in range 3 to 10")
        private String name;
    
        @NotBlank(message = "Email is required")
        @Email(message = "Email should be a valid email")
        private String email;
    
        @Min(value = 18, message = "Age cannot be less than 18")
        @Max(value = 80, message = "Age cannot be greater than 80")
        private int age;
    
        @Pattern(regexp = "^(admin|user)$", message = "Role can be either 'admin' or 'user'")
        private String role;
    
        @Positive(message = "Salary should be a positive number")
        private double salary;
    
        @PastOrPresent(message = "Date of joining cannot be in the future")
        private LocalDate dateOfJoining;
    }
    
    ```
    

---

### **Step 2: Enabling Validation in the Controller**

- We need to **tell Spring Boot to validate** the incoming request.
- Add `@Valid` before the DTO in the controller:
    
    ```Java
    java
    CopyEdit
    @PostMapping("/employees")
    public ResponseEntity<String> createEmployee(@Valid @RequestBody EmployeeDTO employee) {
        return ResponseEntity.ok("Employee created successfully");
    }
    
    ```
    
- **Without** `**@Valid**`, validation will NOT work.

---

## **üìå Understanding Each Validation Annotation**

### **1Ô∏è‚É£** `**@NotNull**`**,** `**@NotEmpty**`**,** `**@NotBlank**`

|   |   |   |
|---|---|---|
|Annotation|**Checks for**|**Use Case**|
|`@NotNull`|**Only null values**|Ensuring a field is **present** (e.g., `Integer age;`)|
|`@NotEmpty`|Null + Empty (`""`, `[]`)|Ensuring a **collection or string is not empty**|
|`@NotBlank`|Null + Empty + Whitespaces (`" "`)|**Best for validating strings**|

- **Example:**
    
    ```Java
    java
    CopyEdit
    @NotBlank(message = "Name cannot be blank")
    private String name;
    
    ```
    

---

### **2Ô∏è‚É£** `**@Size(min, max)**`

- Ensures **string length is within a given range**.
- **Example:**
    
    ```Java
    java
    CopyEdit
    @Size(min = 3, max = 10, message = "Name should be between 3 and 10 characters")
    private String name;
    
    ```
    

---

### **3Ô∏è‚É£** `**@Min**`**,** `**@Max**`

- Ensures **numeric values fall within the given range**.
- **Example:**
    
    ```Java
    java
    CopyEdit
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 80, message = "Age cannot exceed 80")
    private int age;
    
    ```
    

---

### **4Ô∏è‚É£** `**@Email**`

- Ensures **proper email format**.
- **Example:**
    
    ```Java
    java
    CopyEdit
    @Email(message = "Must be a valid email")
    private String email;
    
    ```
    

---

### **5Ô∏è‚É£** `**@Pattern**` **for Regular Expressions**

- Validates a **custom pattern using regex**.
- **Example (Role can only be 'admin' or 'user'):**
    
    ```Java
    java
    CopyEdit
    @Pattern(regexp = "^(admin|user)$", message = "Role must be 'admin' or 'user'")
    private String role;
    
    ```
    

---

### **6Ô∏è‚É£** `**@Past**`**,** `**@Future**`**,** `**@PastOrPresent**`

|   |   |
|---|---|
|Annotation|Ensures date is|
|`@Past`|**Before today**|
|`@Future`|**After today**|
|`@PastOrPresent`|**Today or before**|

- **Example (Date of Joining cannot be in the future):**
    
    ```Java
    java
    CopyEdit
    @PastOrPresent(message = "Date of joining cannot be in the future")
    private LocalDate dateOfJoining;
    
    ```
    

---

## **üöÄ Creating Custom Validation**

### **Scenario: Role should only be 'admin' or 'user'**

### **Step 1: Create a Custom Annotation**

```Java
java
CopyEdit
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmployeeRoleValidator.class)
public @interface EmployeeRoleValidation {
    String message() default "Role must be 'admin' or 'user'";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

```

### **Step 2: Implement Custom Validator**

```Java
java
CopyEdit
public class EmployeeRoleValidator implements ConstraintValidator<EmployeeRoleValidation, String> {

    private static final List<String> VALID_ROLES = Arrays.asList("admin", "user");

    @Override
    public boolean isValid(String role, ConstraintValidatorContext context) {
        return role != null && VALID_ROLES.contains(role.toLowerCase());
    }
}

```

### **Step 3: Use the Custom Annotation**

```Java
java
CopyEdit
@EmployeeRoleValidation
private String role;

```

---

## **üìå Summary (Quick Interview Revision)**

1. **Why validate input?**
    - Prevents **invalid data** from being saved.
    - Enhances **data integrity and security**.
2. **How to enable validation?**
    - Add **Spring Boot Starter Validation** dependency.
    - Use **Jakarta validation annotations** in DTO.
3. **Key Annotations & Use Cases**
    - `@NotBlank`, `@NotNull`, `@NotEmpty`
    - `@Size(min, max)`, `@Min(value)`, `@Max(value)`
    - `@Email`, `@Pattern(regex)`
    - `@Past`, `@Future`, `@PastOrPresent`
    - `@Valid` (for nested object validation)
4. **How to create a custom validation?**
    - Create a **custom annotation**.
    - Implement **ConstraintValidator**.

---