### **Java 8 - Lambdas and Streams**

Java 8 introduced **Lambda Expressions** and **Streams**, two powerful features that make Java code more functional, concise, and efficient. Many developers struggle to understand these concepts due to the lack of comprehensive resources.

This guide provides an **in-depth explanation of Lambda Expressions and Streams**, along with practical examples and key concepts.

---

## **Lambda Expressions**

Lambda Expressions provide a way to define **anonymous functions** that can be used to instantiate **functional interfaces**.

### **1. Understanding Functional Interfaces**

A **functional interface** is an interface that contains **only one abstract method**. These interfaces enable Lambda Expressions.

### **Example: Creating a Functional Interface**

```Java
java
CopyEdit
@FunctionalInterface
interface Walkable {
    int walk(int steps);
}

```

- The `@FunctionalInterface` annotation ensures that only **one method** exists in the interface.
- This annotation is **optional** but helps prevent accidental addition of multiple methods.

### **2. Implementing Functional Interfaces (Older Way)**

Traditionally, we implemented functional interfaces using **classes**:

```Java
java
CopyEdit
class WalkFast implements Walkable {
    @Override
    public int walk(int steps) {
        System.out.println("Walking fast: " + steps + " steps");
        return 2 * steps;
    }
}

```

Usage:

```Java
java
CopyEdit
Walkable obj = new WalkFast();
obj.walk(4); // Walking fast: 4 steps

```

Alternatively, we used **anonymous classes**:

```Java
java
CopyEdit
Walkable obj = new Walkable() {
    @Override
    public int walk(int steps) {
        System.out.println("Walking fast: " + steps + " steps");
        return 2 * steps;
    }
};

```

### **3. Implementing Functional Interfaces with Lambda Expressions (New Way)**

Lambda expressions eliminate the need for **anonymous classes** and make code more concise.

### **Syntax of Lambda Expression**

```Java
java
CopyEdit
(parameters) -> { method body }

```

### **Example: Using Lambda Expression**

```Java
java
CopyEdit
Walkable obj = (steps) -> {
    System.out.println("Walking fast: " + steps + " steps");
    return 2 * steps;
};
obj.walk(4); // Walking fast: 4 steps

```

- No need to create a **class** or use `new`.
- The **method name is omitted** since Java knows the method signature.
- If a method has **one parameter**, parentheses `()` can be omitted:
    
    ```Java
    java
    CopyEdit
    Walkable obj = steps -> steps * 2;
    
    ```
    

### **Lambda with Multiple Parameters**

If the functional interface has multiple parameters:

```Java
java
CopyEdit
@FunctionalInterface
interface Walkable {
    int walk(int steps, boolean isEnabled);
}

```

Lambda implementation:

```Java
java
CopyEdit
Walkable obj = (steps, isEnabled) -> {
    if (isEnabled) {
        return steps * 2;
    }
    return 0;
};

```

### **Single Line Lambda Expressions**

If the body contains only **one line**, curly braces `{}` and `return` can be omitted:

```Java
java
CopyEdit
Walkable obj = (steps) -> steps * 2;

```

---

## **Streams in Java 8**

A **Stream** represents a sequence of elements that **can be processed in a functional style**. Streams use **Lambda Expressions** extensively.

### **1. What is a Stream?**

A **Stream** in Java 8 is a **pipeline of data processing operations** that:

- **Processes elements in a sequence**
- **Does not store data** but operates on the source
- **Uses functional programming concepts**
- **Cannot be reused** once processed

### **2. Creating a Stream**

Streams can be created from **collections** like `List`, `Set`, or `Map`.

### **Example: Creating a Stream from a List**

```Java
java
CopyEdit
List<String> fruits = List.of("Apple", "Banana", "Kiwi");
Stream<String> stream = fruits.stream();

```

- We can also create a **parallel stream** for **multi-threaded processing**:
    
    ```Java
    java
    CopyEdit
    Stream<String> parallelStream = fruits.parallelStream();
    
    ```
    

### **3. Processing a Stream**

Streams provide multiple methods for **processing elements**. Let’s explore them.

### **(a) forEach - Iterating Over Elements**

```Java
java
CopyEdit
fruits.stream().forEach(fruit -> System.out.println(fruit));

```

**Method Reference:**

Instead of using a lambda expression, we can use a **method reference**:

```Java
java
CopyEdit
fruits.stream().forEach(System.out::println);

```

> ⚠️ Streams cannot be reused once processed.
> 
> If we try to iterate over the same stream again, it will throw an `IllegalStateException`.

### **(b) Filtering Data with filter()**

`filter()` allows us to **exclude elements** based on a condition.

```Java
java
CopyEdit
fruits.stream()
      .filter(fruit -> fruit.length() < 5)
      .forEach(System.out::println);

```

**Output:**

```Plain
nginx
CopyEdit
Kiwi

```

- The filter **keeps only elements** where `fruit.length() < 5`.

### **(c) Sorting Data with sorted()**

```Java
java
CopyEdit
fruits.stream()
      .sorted()
      .forEach(System.out::println);

```

**Custom Sorting:**

```Java
java
CopyEdit
fruits.stream()
      .sorted(Comparator.reverseOrder()) // Reverse order
      .forEach(System.out::println);

```

### **(d) Transforming Data with map()**

The `map()` function is used to **transform elements** in a stream.

```Java
java
CopyEdit
fruits.stream()
      .map(fruit -> fruit.length())  // Convert String to Integer
      .forEach(System.out::println);

```

**Chaining map() operations:**

```Java
java
CopyEdit
fruits.stream()
      .map(fruit -> fruit.length())
      .map(len -> len * 2)
      .forEach(System.out::println);

```

### **(e) Collecting Data with collect()**

The `collect()` method converts a Stream **back into a collection**.

```Java
java
CopyEdit
List<Integer> fruitLengths = fruits.stream()
                                   .map(String::length)
                                   .collect(Collectors.toList());

```

**Convert to a Set:**

```Java
java
CopyEdit
Set<Integer> uniqueLengths = fruits.stream()
                                   .map(String::length)
                                   .collect(Collectors.toSet());

```

**Convert to a Map:**

```Java
java
CopyEdit
Map<String, Integer> fruitMap = fruits.stream()
                                      .collect(Collectors.toMap(fruit -> fruit, fruit -> fruit.length()));

```

### **(f) Removing Duplicates with distinct()**

```Java
java
CopyEdit
fruits.stream()
      .distinct()
      .forEach(System.out::println);

```

### **(g) Counting Elements with count()**

```Java
java
CopyEdit
long count = fruits.stream()
                   .filter(fruit -> fruit.length() > 4)
                   .count();

```

### **(h) Finding Elements with findFirst()**

```Java
java
CopyEdit
Optional<String> firstFruit = fruits.stream()
                                    .findFirst();

```

### **(i) Reducing Elements with reduce()**

```Java
java
CopyEdit
int totalLength = fruits.stream()
                        .map(String::length)
                        .reduce(0, Integer::sum);

```

---

## **Lambda Method Reference**

Instead of writing explicit **Lambda Expressions**, we can use **Method References**.

### **Example 1: Using Method Reference in forEach**

```Java
java
CopyEdit
fruits.stream().forEach(System.out::println);

```

Instead of:

```Java
java
CopyEdit
fruits.stream().forEach(fruit -> System.out.println(fruit));

```

### **Example 2: Using Method Reference in map()**

```Java
java
CopyEdit
fruits.stream()
      .map(String::length) // Instead of fruit -> fruit.length()
      .forEach(System.out::println);

```

---

## **Summary (Quick Revision)**

- **Lambda Expressions** provide a concise way to define anonymous functions.
- **Functional Interfaces** contain **only one abstract method**.
- **Streams** allow functional-style processing of collections.
- **Common Stream operations:**
    - `forEach()`
    - `filter()`
    - `sorted()`
    - `map()`
    - `collect()`
    - `distinct()`
    - `count()`
    - `findFirst()`
    - `reduce()`
- **Method References (**`**::**`**)** make Lambda Expressions even shorter.