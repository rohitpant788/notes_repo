  

## **1Ô∏è‚É£ Introduction to the Service Layer**

- The **service layer** acts as a **bridge** between the **persistence layer** (database) and the **presentation layer** (controllers).
- It helps in **modularizing** the code, making it more **scalable** and **testable**.
- Without a service layer, controllers directly interact with repositories, which is **not recommended**.
- The **service layer encapsulates**:
    - **Business logic**
    - **Security**
    - **Data transformation (DTO mapping)**
    - **Logging and monitoring**

---

## **2Ô∏è‚É£ Why Do We Need a Service Layer?**

‚úÖ **Avoid Code Duplication**:

- Suppose we have multiple controllers (`EmployeeController`, `DepartmentController`).
- If both need to interact with `EmployeeRepository`, each controller will duplicate logic for authentication, logging, and fetching data.

‚úÖ **Enhance Maintainability**:

- Instead of writing the same logic in multiple controllers, we define it **once** in the service layer.
- Controllers only **call** the service layer, keeping them **clean**.

‚úÖ **Improve Scalability**:

- **Business logic** resides in **one place**.
- Future enhancements (like adding caching or new logic) can be done without modifying controllers.

‚úÖ **Implement Security and Logging**:

- **Authentication** (e.g., verifying user access before fetching data).
- **Logging** (e.g., tracking who requested what data).

---

## **3Ô∏è‚É£ Implementing the Service Layer**

### **Step 1: Creating the Service Class**

- We create a new **EmployeeService** inside the `service` package.

```Java
java
CopyEdit
package com.example.service;

import org.springframework.stereotype.Service;

@Service // Marks this class as a service bean
public class EmployeeService {
   // Business logic goes here
}

```

üìå `**@Service**` **annotation** ensures that this class is managed by Spring's dependency injection.

---

### **Step 2: Injecting Service into Controller**

- Previously, we injected **repositories** directly inside controllers (**bad practice**):

```Java
java
CopyEdit
// ‚ùå Wrong Approach
@RestController
public class EmployeeController {
   private final EmployeeRepository employeeRepository;

   @Autowired
   public EmployeeController(EmployeeRepository employeeRepository) {
       this.employeeRepository = employeeRepository;
   }
}

```

- Instead, we **inject the service layer** into the controller:

```Java
java
CopyEdit
// ‚úÖ Correct Approach
@RestController
public class EmployeeController {
   private final EmployeeService employeeService;

   @Autowired
   public EmployeeController(EmployeeService employeeService) {
       this.employeeService = employeeService;
   }
}

```

**üîπ Benefits of this approach**:

- **Controllers only handle HTTP requests**.
- **Business logic is moved to the service layer**.
- **Code becomes reusable across multiple controllers**.

---

## **4Ô∏è‚É£ Implementing Business Logic in the Service Layer**

### **Fetching Employee by ID**

1Ô∏è‚É£ **Move** `**findById()**` **logic from controller to service layer**

2Ô∏è‚É£ **Inject** `**EmployeeRepository**` **inside service layer**

3Ô∏è‚É£ **Implement the** `**getEmployeeById()**` **method**

```Java
java
CopyEdit
@Service
public class EmployeeService {
   private final EmployeeRepository employeeRepository;

   @Autowired
   public EmployeeService(EmployeeRepository employeeRepository) {
       this.employeeRepository = employeeRepository;
   }

   public EmployeeEntity getEmployeeById(Long id) {
       return employeeRepository.findById(id).orElse(null);
   }
}

```

üìå **Key Takeaways:**

- The **controller no longer directly interacts with the repository**.
- The service layer **fetches the employee** and **handles missing data cases**.

---

### **Fetching All Employees**

```Java
java
CopyEdit
public List<EmployeeEntity> getAllEmployees() {
   return employeeRepository.findAll();
}

```

- **Encapsulates** database interaction within the service layer.

---

### **Creating a New Employee**

```Java
java
CopyEdit
public EmployeeEntity createEmployee(EmployeeEntity employee) {
   return employeeRepository.save(employee);
}

```

- Again, the **controller does not interact with** `**save()**` **directly**.

---

## **5Ô∏è‚É£ Using DTOs to Separate Entity from Controller**

üîπ **Problem**: Controllers should **not return database entities** directly.

üîπ **Solution**: **Use DTOs (Data Transfer Objects) to return only required data**.

### **Example**

```Java
java
CopyEdit
public EmployeeDTO getEmployeeById(Long id) {
   EmployeeEntity employee = employeeRepository.findById(id).orElse(null);
   return new EmployeeDTO(employee.getId(), employee.getName(), employee.getEmail());
}

```

**Why DTOs?**

- **Prevents exposing database structure**
- **Allows flexible API responses**
- **Enables custom field transformations**

---

## **6Ô∏è‚É£ Automating DTO Conversion Using ModelMapper**

üîπ **Problem**: Manually converting entities to DTOs can be repetitive.

üîπ **Solution**: Use **ModelMapper**.

### **Adding ModelMapper Dependency**

üìå **In** `**pom.xml**`

```XML
xml
CopyEdit
<dependency>
   <groupId>org.modelmapper</groupId>
   <artifactId>modelmapper</artifactId>
   <version>3.0.0</version>
</dependency>

```

---

### **Creating a Global ModelMapper Bean**

üìå **Define a configuration class to manage ModelMapper as a Spring Bean**

```Java
java
CopyEdit
@Configuration
public class ModelMapperConfig {
   @Bean
   public ModelMapper modelMapper() {
       return new ModelMapper();
   }
}

```

---

### **Injecting ModelMapper into the Service Layer**

```Java
java
CopyEdit
@Service
public class EmployeeService {
   private final ModelMapper modelMapper;
   private final EmployeeRepository employeeRepository;

   @Autowired
   public EmployeeService(ModelMapper modelMapper, EmployeeRepository employeeRepository) {
       this.modelMapper = modelMapper;
       this.employeeRepository = employeeRepository;
   }

   public EmployeeDTO getEmployeeById(Long id) {
       EmployeeEntity employee = employeeRepository.findById(id).orElse(null);
       return modelMapper.map(employee, EmployeeDTO.class);
   }
}

```

üìå **ModelMapper automatically maps fields from EmployeeEntity to EmployeeDTO**.

---

## **7Ô∏è‚É£ Using Streams to Convert Lists of Entities to DTOs**

```Java
java
CopyEdit
public List<EmployeeDTO> getAllEmployees() {
   List<EmployeeEntity> employees = employeeRepository.findAll();
   return employees.stream()
       .map(employee -> modelMapper.map(employee, EmployeeDTO.class))
       .collect(Collectors.toList());
}

```

üìå **Benefits**:

- **No need for manual field mappings**
- **Scales well with large datasets**

---

## **8Ô∏è‚É£ Handling Request and Response Properly**

- Controllers should **return** `**ResponseEntity**` instead of plain objects.

üìå **Example of a Controller Returning** `**ResponseEntity**`

```Java
java
CopyEdit
@GetMapping("/{id}")
public ResponseEntity<EmployeeDTO> getEmployeeById(@PathVariable Long id) {
   EmployeeDTO employee = employeeService.getEmployeeById(id);
   return (employee != null) ? ResponseEntity.ok(employee) : ResponseEntity.notFound().build();
}

```

üìå **Why Use** `**ResponseEntity**`**?**

- Provides **proper HTTP status codes** (e.g., `404 Not Found`, `200 OK`)
- Enhances **API response structure**.

---

## **9Ô∏è‚É£ Summary ‚Äì Quick Revision for Interview**

‚úÖ **Service Layer** acts as a **bridge** between **Controller and Repository**.

‚úÖ **Avoid injecting repositories directly into controllers** ‚Äì Use **services instead**.

‚úÖ **Move business logic to the service layer** to improve **scalability**.

‚úÖ **Use DTOs** instead of exposing database entities.

‚úÖ **Use ModelMapper** for efficient **entity-to-DTO conversion**.

‚úÖ **Use ResponseEntity** in controllers for **better API responses**.

‚úÖ **Stream API** helps in **converting entity lists to DTOs efficiently**.

---