  

  

- **Question 1 :**  
      
    If I need to create a **one-to-many** relationship between **Department** and **Employee** (**one department can have multiple employees**):  
    > How do we decide who will own the relationship?  
    > Which table will have the foreign key?  
    > How is this decision made in JPA?  
      
    
    ---
    
    ## **1Ô∏è‚É£ Understanding the One-to-Many Relationship**
    
    In a **one-to-many** relationship:
    
    - **One Department can have multiple Employees**.
    - **Each Employee belongs to only one Department**.
    
    üìå **Decision Rule:**
    
    - The entity that **holds the foreign key** in the database **owns the relationship**.
    - In a **one-to-many** relationship, the **"many" side** (i.e., `Employee`) **usually owns the relationship** because it contains the foreign key.
    
    ---
    
    ## **2Ô∏è‚É£ Where Does the Foreign Key Go?**
    
    ‚úÖ **Best Practice:**
    
    - **Foreign key (**`**department_id**`**) should be in the** `**Employee**` **table.**
    - This avoids creating an unnecessary **join table**.
    - Improves **query performance** since lookups on `Employee` can be optimized.
    
    ### **Table Structure in the Database**
    
    | **Department Table** |  
    |----|--------------|  
    |  
    `id` (PK) | `name` |
    
    | **Employee Table** |  
    |----|------------|------------|  
    |  
    `id` (PK) | `name` | `department_id` (FK) |
    
    üìå **Foreign Key (**`**department_id**`**) is stored in the** `**Employee**` **table, linking each employee to a department.**
    
    ---
    
    ## **3Ô∏è‚É£ JPA Implementation:**
    
    ### **Department Entity (Owning Side)**
    
    ```Java
    java
    CopyEdit
    @Entity
    public class Department {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
        private List<Employee> employees;
    
        // Getters & Setters
    }
    
    ```
    
    üìå **Explanation:**
    
    - `@OneToMany(mappedBy = "department")` ‚Üí **Department does NOT own the relationship** (mapped by `department` in `Employee`).
    - `cascade = CascadeType.ALL` ‚Üí If a `Department` is deleted, all associated `Employees` are also deleted.
    - `employees` is a **collection** representing all employees under a department.
    
    ---
    
    ### **Employee Entity (Owning Side - Holds Foreign Key)**
    
    ```Java
    java
    CopyEdit
    @Entity
    public class Employee {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        @ManyToOne
        @JoinColumn(name = "department_id", nullable = false)
        private Department department;
    
        // Getters & Setters
    }
    
    ```
    
    üìå **Explanation:**
    
    - `@ManyToOne` ‚Üí **Employee owns the relationship**.
    - `@JoinColumn(name = "department_id")` ‚Üí Creates a foreign key column (`department_id`) in the `Employee` table.
    - `nullable = false` ‚Üí Every employee **must belong to a department**.
    
    ---
    
    ## **4Ô∏è‚É£ How is the Decision Made?**
    
    |   |   |
    |---|---|
    |Decision Factor|Best Practice|
    |**Which side holds the foreign key?**|The **"many" side (**`**Employee**`**)** owns the foreign key (`department_id`)|
    |**Who owns the relationship?**|The **"many" side (**`**Employee**`**)** owns it with `@ManyToOne`|
    |**Who has** `**mappedBy**`**?**|The **"one" side (**`**Department**`**)** has `mappedBy="department"`|
    |**Do we need a join table?**|‚ùå **No,** because a direct foreign key in `Employee` is better|
    
    üöÄ **Following this approach keeps the schema optimized, avoids redundant join tables, and ensures easy querying.**
    
    ---
    
    ## **5Ô∏è‚É£ Alternative Approach: Using a Join Table (Less Efficient)**
    
    üìå **If we wanted a** `**@JoinTable**` **instead of a direct** `**@JoinColumn**`**, we could do this:**
    
    ### **Department Entity (Owning Side)**
    
    ```Java
    java
    CopyEdit
    @OneToMany
    @JoinTable(
        name = "department_employee",
        joinColumns = @JoinColumn(name = "department_id"),
        inverseJoinColumns = @JoinColumn(name = "employee_id")
    )
    private List<Employee> employees;
    
    ```
    
    üö® **Drawbacks of** `**@JoinTable**` **in One-to-Many:**
    
    - Creates an **extra table (**`**department_employee**`**)**.
    - **Slower queries** due to additional joins.
    - **Unnecessary for One-to-Many** (Best for Many-to-Many).
    
    ‚úÖ **For One-to-Many,** `**@JoinColumn**` **on the** `**@ManyToOne**` **side is better**.
    
    ---
    
    ## **6Ô∏è‚É£ Summary**
    
    |   |   |
    |---|---|
    |Aspect|Best Practice|
    |**Who owns the relationship?**|**Employee** (`@ManyToOne` with `@JoinColumn`)|
    |**Where does the foreign key go?**|**Employee Table (**`**department_id**`**)**|
    |**How does** `**Department**` **reference** `**Employee**`**?**|`@OneToMany(mappedBy = "department")`|
    |**Should we use a join table?**|‚ùå No, direct foreign key is better|
    
    ### **Final Answer:**
    
    - The **"many" side (**`**Employee**`**)** owns the relationship.
    - The **foreign key (**`**department_id**`**) is in the** `**Employee**` **table**.
    - Use `**@OneToMany(mappedBy = "department")**` in `Department`.
    - Use `**@ManyToOne @JoinColumn(name = "department_id")**` in `Employee`.

  

  

  

- **Question 2 :**  
    In the below reference code, I am trying to **assign an employee to a department** by:  
    1. Retrieving the  
    `DepartmentEntity` using `findById(departmentId)`.  
    2. Retrieving the  
    `EmployeeEntity` using `findById(employeeId)`.  
    3. Adding the  
    `Employee` to `Department.getWorkers()` and saving the `Department` using `departmentRepository.save(department)`.  
    **Reference Code:**  
      
    `Optional<DepartmentEntity> departmentEntity = departmentRepository.findById(departmentId); Optional<EmployeeEntity> employeeEntity = employeeRepository.findById(employeeId); return departmentEntity.flatMap(department -> employeeEntity.map(employee -> { department.getWorkers().add(employee); // Adding employee to department's worker list return departmentRepository.save(department); // Saving the department }) )` ;  
    **Question:**  
    **>**  
    Will this update the `department_id` in the `Employee` table?  
    > Will this correctly update the relationship?  
    
      
    
    ## **1Ô∏è‚É£ What Is Happening in This Code?**
    
    - We are **fetching** the `DepartmentEntity` and `EmployeeEntity` as `Optional<T>`.
    - We are using `**flatMap**` **and** `**map**` to ensure both entities exist before modifying them.
    - We are **adding the** `**Employee**` **to the** `**Department's**` **worker list (**`**getWorkers()**`**)**.
    - Finally, we are **saving the** `**Department**` **using** `**departmentRepository.save(department)**`.
    
    ---
    
    ## **2Ô∏è‚É£ Will It Update** `**department_id**` **in the** `**Employee**` **Table?**
    
    ‚ùå **No, this will NOT update the** `**department_id**` **in the** `**Employee**` **table correctly.**
    
    üìå **Why?**
    
    - The **foreign key (**`**department_id**`**) is stored in the** `**Employee**` **table**, and `Employee` **owns the relationship**.
    - Adding an `Employee` to `Department.getWorkers()` **only modifies the** `**Department**` **object**, but **does NOT update the** `**department_id**` **in** `**Employee**`.
    - Since the **relationship is owned by** `**Employee**`, changes must be made in the `**EmployeeEntity**`, not just in `Department`.
    
    üö® **Issue:**
    
    - `department.getWorkers().add(employee)` only modifies the **inverse side (**`**@OneToMany**` **list in** `**Department**`**)**, but does **not** affect the owning side (`@ManyToOne` in `Employee`).
    
    ‚úÖ **The correct way to update the relationship is to update the** `**Employee**` **entity.**
    
    ---
    
    ## **3Ô∏è‚É£ Correct Way to Update** `**department_id**` **for Employee**
    
    Since `**Employee**` **owns the relationship**, we must **set** `**department**` **inside** `**EmployeeEntity**` and then **save the** `**Employee**`, NOT the `Department`.
    
    ### **Corrected Code:**
    
    ```Java
    java
    CopyEdit
    Optional<DepartmentEntity> departmentEntity = departmentRepository.findById(departmentId);
    Optional<EmployeeEntity> employeeEntity = employeeRepository.findById(employeeId);
    
    return departmentEntity.flatMap(department ->
        employeeEntity.map(employee -> {
            employee.setDepartment(department); // ‚úÖ Correctly assigning department to employee
            return employeeRepository.save(employee); // ‚úÖ Saving Employee instead of Department
        })
    );
    
    ```
    
    ‚úÖ **Now, the** `**department_id**` **in the** `**Employee**` **table is correctly updated!**
    
    üìå **Key Fix:**
    
    - Instead of adding the employee to `department.getWorkers()`, we update the owning side by setting `employee.setDepartment(department)`.
    - Since `Employee` owns the relationship, saving `Employee` ensures that `department_id` is correctly updated in the database.
    
    ---
    
    ## **4Ô∏è‚É£ Why Doesn‚Äôt** `**departmentRepository.save(department)**` **Work?**
    
    If we save the `Department` instead:
    
    ```Java
    java
    CopyEdit
    return departmentRepository.save(department);
    
    ```
    
    ‚ùå This **only updates the** `**Department**` **entity**, but does **not update the** `**department_id**` **in** `**Employee**`, because:
    
    - JPA **only synchronizes the owning side** (`@ManyToOne` in `Employee`), NOT the inverse (`@OneToMany` in `Department`).
    - **The** `**workers**` **list in** `**Department**` **is just a mapped collection and does NOT dictate foreign keys.**
    
    ---
    
    ## **5Ô∏è‚É£ Summary**
    
    |   |   |   |
    |---|---|---|
    |Approach|Does It Update `department_id` in Employee Table?|Why?|
    |**Adding Employee to** `**department.getWorkers()**` **and saving** `**Department**`|‚ùå **No**|`Department.getWorkers()` is just a mapped list and does NOT update the foreign key|
    |**Setting** `**employee.setDepartment(department)**` **and saving** `**Employee**`|‚úÖ **Yes**|`Employee` owns the relationship, so changes must be made here|
    
    ### **Final Answer**
    
    - ‚ùå **Your current code will NOT update** `**department_id**` **in** `**Employee**` because you are modifying the **inverse (**`**@OneToMany**`**)** side of the relationship.
    - ‚úÖ **To properly update the relationship**, use `employee.setDepartment(department)` and **save the** `**EmployeeEntity**`.

  

  

  

### **Question 3:**

In the below reference code, I have a **Many-to-Many** relationship between `Department` and `Employee` (freelancers).

1. In `EmployeeEntity.java`, I **own the relationship** using `@ManyToMany` with `@JoinTable`.
2. In `DepartmentEntity.java`, I **use** `**mappedBy**` to mark it as the **inverse side**.
3. In my **service layer**, I am saving the relationship using `departmentRepository.save(department)`, but it is **not persisting** in the database.

### **Reference Code**

### **EmployeeEntity (Owning Side)**

```Java

@Entity
public class EmployeeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany
    @JoinTable(
        name = "freelancer_department_mapping",
        joinColumns = @JoinColumn(name = "employee_id"),
        inverseJoinColumns = @JoinColumn(name = "department_id")
    )
    @JsonIgnore
    private List<DepartmentEntity> departments;

    // Getters & Setters
}

```

### **DepartmentEntity (Inverse Side)**

```Java

@Entity
public class DepartmentEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(mappedBy = "departments")
    private List<EmployeeEntity> freelancers;

    // Getters & Setters
}

```

### **Service Layer**

```Java

public DepartmentEntity assignFreelancerToDepartment(Long departmentId, Long employeeId) {
    Optional<DepartmentEntity> departmentEntity = departmentRepository.findById(departmentId);
    Optional<EmployeeEntity> employeeEntity = employeeRepository.findById(employeeId);

    return departmentEntity.flatMap(department ->
        employeeEntity.map(employee -> {
            department.getFreelancers().add(employee); // Adding employee to department
            return departmentRepository.save(department); // Saving department
        })
    ).orElseThrow(() -> new EntityNotFoundException("Department or Employee not found"));
}

```

### **Question:**

- **Why is** `**departmentRepository.save(department)**` **not persisting the relationship in the database?**
- **Is there something wrong with this approach?**

  

- Answer
    
    ## **1Ô∏è‚É£ What‚Äôs the Issue?**
    
    üö® **Issue:** `**departmentRepository.save(department)**` **does NOT update the Many-to-Many relationship correctly**
    
    - **Many-to-Many relationships are owned by the entity that defines** `**@JoinTable**`.
    - **In this case,** `**EmployeeEntity**` **owns the relationship**, meaning changes must be made in `EmployeeEntity`, NOT in `DepartmentEntity`.
    - **JPA only synchronizes the owning side (**`**EmployeeEntity**`**), NOT the inverse side (**`**DepartmentEntity**`**).**
    
    üìå **What‚Äôs happening?**
    
    - **You are modifying** `**DepartmentEntity**` **(the inverse side)** and saving it.
    - **JPA ignores updates to** `**@OneToMany**` **and** `**@ManyToMany**` **collections on the inverse side**.
    - **The correct approach is to update** `**EmployeeEntity**`**, the owning side.**
    
    ---
    
    ## **2Ô∏è‚É£ Correct Approach: Save the Owning Side (**`**EmployeeEntity**`**)**
    
    ‚úÖ Instead of saving `DepartmentEntity`, update `**EmployeeEntity**` and save it.
    
    ### **Corrected Service Layer Code**
    
    ```Java
    java
    CopyEdit
    public EmployeeEntity assignFreelancerToDepartment(Long departmentId, Long employeeId) {
        Optional<DepartmentEntity> departmentEntity = departmentRepository.findById(departmentId);
        Optional<EmployeeEntity> employeeEntity = employeeRepository.findById(employeeId);
    
        return employeeEntity.flatMap(employee ->
            departmentEntity.map(department -> {
                employee.getDepartments().add(department); // ‚úÖ Update the owning side
                return employeeRepository.save(employee); // ‚úÖ Save the owning side
            })
        ).orElseThrow(() -> new EntityNotFoundException("Department or Employee not found"));
    }
    
    ```
    
    üìå **Key Fix:**
    
    - **Modify the** `**departments**` **list in** `**EmployeeEntity**` **(the owning side).**
    - **Save the** `**EmployeeEntity**`**, NOT** `**DepartmentEntity**`**.**
    - **Now, JPA correctly updates the Many-to-Many relationship in the** `**freelancer_department_mapping**` **table.**
    
    ---
    
    ## **3Ô∏è‚É£ Why Does Saving** `**DepartmentEntity**` **Not Work?**
    
    |   |   |   |
    |---|---|---|
    |Approach|Works?|Why?|
    |`department.getFreelancers().add(employee)` then `departmentRepository.save(department)`|‚ùå **No**|`DepartmentEntity` does NOT own the relationship, so JPA ignores changes.|
    |`employee.getDepartments().add(department)` then `employeeRepository.save(employee)`|‚úÖ **Yes**|`EmployeeEntity` owns the relationship (`@JoinTable` is defined there), so JPA persists changes.|
    
    üö® **JPA Only Synchronizes the Owning Side!**
    
    - The **inverse side (**`**DepartmentEntity**`**) is just a mapped collection** and is **NOT responsible for persisting changes**.
    - **Only modifications made to the owning side (**`**EmployeeEntity**`**) trigger database updates.**
    
    ---
    
    ## **4Ô∏è‚É£ Summary of Fix**
    
    |   |   |   |
    |---|---|---|
    |Step|Incorrect Approach|Correct Approach|
    |**Modify Relationship**|`department.getFreelancers().add(employee);`|`employee.getDepartments().add(department);`|
    |**Save Entity**|`departmentRepository.save(department);`|`employeeRepository.save(employee);`|
    
    ‚úÖ **Final Answer:**
    
    - The **owning side (**`**EmployeeEntity**`**) must be updated and saved**, NOT the inverse side (`DepartmentEntity`).
    - **To persist the relationship, modify the** `**List<DepartmentEntity>**` **in** `**EmployeeEntity**` **and save** `**EmployeeEntity**`.
    - **JPA does NOT track changes in inverse collections (**`**mappedBy**`**).**